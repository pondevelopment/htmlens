<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTMLens - Semantic Knowledge Graph Extractor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        header { text-align: center; color: white; margin-bottom: 40px; }
        h1 { font-size: 3em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .tagline { font-size: 1.2em; opacity: 0.9; }
        .card { background: white; border-radius: 12px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); margin-bottom: 20px; }
        .input-section { margin-bottom: 20px; }
        label { display: block; font-weight: 600; margin-bottom: 8px; color: #555; }
        input[type="url"] { width: 100%; padding: 12px 16px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; }
        input[type="url"]:focus { outline: none; border-color: #667eea; }
        .examples-section { margin-bottom: 20px; padding-top: 10px; }
        .example-buttons { display: flex; gap: 8px; flex-wrap: wrap; }
        .example-btn { flex: 0 1 auto; padding: 8px 16px; font-size: 14px; font-weight: 500; background: #f0f4ff; color: #667eea; border: 1px solid #d0d9ff; border-radius: 6px; cursor: pointer; transition: all 0.2s; }
        .example-btn:hover { background: #667eea; color: white; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3); }
        .button-group { display: flex; gap: 12px; margin-top: 20px; }
        button { flex: 1; padding: 14px 24px; font-size: 16px; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .btn-secondary { background: #f5f5f5; color: #666; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        .loading { display: none; text-align: center; padding: 20px; color: #667eea; }
        .loading.active { display: block; }
        .spinner { border: 3px solid #f3f3f3; border-top: 3px solid #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .results { display: none; }
        .results.active { display: block; }
        .tabs { display: flex; gap: 4px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; }
        .tab { padding: 12px 24px; background: transparent; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 600; color: #666; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .json-output { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; overflow-x: auto; max-height: 600px; font-family: 'Courier New', monospace; font-size: 14px; white-space: pre-wrap; }
        .json-output .json-key { color: #881391; }
        .json-output .json-string { color: #1A1AA6; }
        .json-output .json-number { color: #1C00CF; }
        .json-output .json-boolean { color: #0D22FF; }
        .json-output .json-null { color: #808080; }
        .markdown-output { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 20px; max-height: 600px; overflow-y: auto; overflow-x: auto; font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap; }
        .markdown-output table { border-collapse: collapse; margin: 10px 0; width: auto; background: white; }
        .markdown-output th, .markdown-output td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
        .markdown-output th { background: #667eea; color: white; font-weight: 600; }
        .markdown-output tr:nth-child(even) { background: #f9f9f9; }
        .markdown-output hr { border: none; border-top: 2px solid #667eea; margin: 15px 0; }
        .error { background: #fee; border: 2px solid #fcc; border-radius: 8px; padding: 16px; color: #c33; margin-top: 20px; display: none; }
        
        /* Insights styles */
        .insights-container { max-height: 600px; overflow-y: auto; }
        .status-badge { display: inline-block; padding: 8px 16px; border-radius: 20px; font-weight: 600; font-size: 14px; margin-bottom: 20px; }
        .status-excellent { background: #d4edda; color: #155724; }
        .status-good { background: #d1ecf1; color: #0c5460; }
        .status-needs-attention { background: #fff3cd; color: #856404; }
        .status-critical { background: #f8d7da; color: #721c24; }
        .insight-section { margin-bottom: 24px; }
        .insight-header { font-size: 18px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .insight-card { background: #f8f9fa; border-left: 4px solid #ccc; padding: 16px; margin-bottom: 12px; border-radius: 4px; }
        .insight-card.critical { border-left-color: #dc3545; background: #fff5f5; }
        .insight-card.high { border-left-color: #ffc107; background: #fffbf0; }
        .insight-card.recommended { border-left-color: #17a2b8; background: #d1ecf1; }
        .insight-card.optional { border-left-color: #6c757d; background: #f8f9fa; }
        .insight-title { font-weight: 600; margin-bottom: 6px; color: #333; }
        .insight-why { color: #666; font-size: 14px; margin-bottom: 8px; }
        .insight-fix { background: white; border: 1px solid #e0e0e0; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 13px; margin-top: 8px; }
        .insight-impact { color: #667eea; font-size: 13px; font-style: italic; }
        .insight-reference { font-size: 12px; margin-top: 8px; }
        .insight-reference a { color: #667eea; text-decoration: none; }
        .insight-reference a:hover { text-decoration: underline; }
        .strengths-list { list-style: none; padding: 0; }
        .strengths-list li { padding: 8px 12px; background: #d4edda; border-radius: 4px; margin-bottom: 8px; color: #155724; }
        .rich-results { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; }
        .rich-result { padding: 8px 12px; border-radius: 6px; font-size: 13px; font-weight: 500; }
        .rich-result.eligible { background: #d4edda; color: #155724; }
        .rich-result.partial { background: #fff3cd; color: #856404; }
        .rich-result.not-eligible { background: #f8d7da; color: #721c24; }
        
        /* AI Readiness Styles */
        .ai-readiness-container { padding: 20px; }
        .ai-readiness-container h2 { color: #667eea; margin-bottom: 10px; }
        .ai-readiness-container p { color: #666; line-height: 1.6; }
        .well-known-checks, .ai-plugin-status, .mcp-status, .openapi-status, .robots-txt-status { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; border: 1px solid #e0e0e0; }
        .well-known-checks h4, .ai-plugin-status h4, .mcp-status h4, .openapi-status h4, .robots-txt-status h4 { margin-top: 0; color: #333; font-size: 18px; margin-bottom: 15px; }
        .file-checks { margin-top: 10px; }
        .file-check { padding: 12px; margin: 8px 0; background: white; border-radius: 6px; font-size: 14px; border-left: 3px solid #28a745; }
        .file-check.critical-missing { background: #fff3cd; border-left: 4px solid #ffc107; font-weight: 500; }
        .invalid { color: #dc3545; font-weight: bold; font-size: 12px; }
        .plugin-issues, .mcp-issues, .api-issues, .robots-issues { color: #dc3545; margin-top: 10px; font-size: 13px; padding: 10px; background: #f8d7da; border-radius: 6px; }
        .ai-plugin-status div, .mcp-status div, .openapi-status div, .robots-txt-status div { margin: 8px 0; padding: 8px; background: white; border-radius: 4px; }
        .mcp-capabilities ul { list-style: none; padding-left: 20px; margin: 8px 0; }
        .mcp-capabilities li { padding: 4px 0; }
        .ai-crawlers-table { width: 100%; border-collapse: collapse; margin: 10px 0; background: white; }
        .ai-crawlers-table th { background: #667eea; color: white; padding: 10px; text-align: left; }
        .ai-crawlers-table td { padding: 8px; border-bottom: 1px solid #e0e0e0; }
        .ai-crawlers-table tr.access-blocked { background: #f8d7da; }
        .ai-crawlers-table tr.access-allowed { background: #d4edda; }
        .ai-crawlers-table tr.access-partial { background: #fff3cd; }
        .ai-crawlers-table .rules-cell { font-size: 12px; color: #666; max-width: 300px; word-wrap: break-word; }
        .sitemap-list ul { list-style: none; padding-left: 20px; margin: 8px 0; }
        .sitemap-list li { padding: 4px 0; }
        .robots-warning { background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 10px 0; font-weight: 500; }
        .robots-recommendation { background: #d1ecf1; border-left: 4px solid #0c5460; color: #0c5460; padding: 10px; margin: 10px 0; }
        .bot-description { font-size: 13px; color: #666; font-style: italic; margin-top: 4px; }
        .collapsible-rules { cursor: pointer; color: #667eea; text-decoration: underline; user-select: none; }
        .rules-detail { display: none; margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-family: monospace; font-size: 12px; }
        .rules-detail.show { display: block; }
        .explainer-box { background: #e7f3ff; border-left: 4px solid #2196F3; padding: 12px; margin: 15px 0; border-radius: 4px; }
        .explainer-box strong { color: #1976D2; }
        .benefit-box { background: #f0fff4; border-left: 4px solid #28a745; padding: 10px; margin: 8px 0; border-radius: 4px; font-size: 13px; }
        .benefit-box strong { color: #155724; }
        .impact-box { background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 8px 0; border-radius: 4px; font-size: 13px; }
        .impact-box strong { color: #856404; }
        .section-intro { background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; line-height: 1.6; }
        .file-link { display: inline-block; margin-top: 4px; font-size: 12px; }
        .file-link a { color: #667eea; text-decoration: none; }
        
        /* Sitemap Styles */
        .sitemap-status { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; border: 1px solid #e0e0e0; }
        .sitemap-status h3 { color: #667eea; margin-top: 0; margin-bottom: 15px; }
        .sitemap-status h4 { color: #333; font-size: 16px; margin-top: 15px; margin-bottom: 10px; }
        .sitemap-status > div { margin: 8px 0; padding: 8px; background: white; border-radius: 4px; }
        .sitemap-stats, .content-types, .nested-sitemaps, .sample-urls, .sitemap-issues, .sitemap-recommendations { margin-top: 15px; padding: 15px; background: white; border-radius: 6px; }
        .sitemap-stats-table, .content-types-table, .sample-urls-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .sitemap-stats-table td, .content-types-table td { padding: 8px; border-bottom: 1px solid #e0e0e0; }
        .sitemap-stats-table td:first-child, .content-types-table td:first-child { font-weight: 500; color: #555; }
        .sitemap-stats-table td:last-child, .content-types-table td:last-child { text-align: right; color: #667eea; font-weight: 500; }
        .sample-urls-table th { background: #667eea; color: white; padding: 10px; text-align: left; font-size: 13px; }
        .sample-urls-table td { padding: 8px; border-bottom: 1px solid #e0e0e0; font-size: 13px; }
        .sample-urls-table a { color: #667eea; text-decoration: none; }
        .sample-urls-table a:hover { text-decoration: underline; }
        .sitemap-issues ul, .sitemap-recommendations ul { list-style: none; padding-left: 0; margin: 8px 0; }
        .sitemap-issues li, .sitemap-recommendations li { padding: 6px 10px; margin: 4px 0; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; }
        .sitemap-recommendations li { background: #d1ecf1; border-left: 3px solid #17a2b8; color: #0c5460; }
        .sitemap-recommendation { background: #d1ecf1; border-left: 4px solid #0c5460; color: #0c5460; padding: 10px; margin: 10px 0; }
        
        /* Semantic HTML Styles */
        .semantic-html-status { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; border: 1px solid #e0e0e0; }
        .semantic-html-status h3 { color: #667eea; margin-top: 0; margin-bottom: 15px; }
        .semantic-html-status h4 { color: #333; font-size: 16px; margin-top: 15px; margin-bottom: 10px; }
        .score-description { font-size: 14px; color: #666; margin-bottom: 15px; text-align: center; }
        .landmarks-section, .headings-section, .accessibility-section, .semantic-issues, .semantic-recommendations { 
            margin-top: 15px; padding: 15px; background: white; border-radius: 6px; 
        }
        .landmarks-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px; }
        .landmark-item { padding: 10px; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #667eea; }
        .heading-distribution { margin-top: 10px; }
        .heading-badge { display: inline-block; padding: 4px 12px; background: #667eea; color: white; border-radius: 12px; margin-right: 6px; font-size: 13px; }
        .accessibility-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .accessibility-table td { padding: 12px; border-bottom: 1px solid #e0e0e0; }
        .accessibility-table td:first-child { font-weight: 500; color: #555; }
        .accessibility-table td:last-child { text-align: right; font-weight: 500; }
        .accessibility-table .good { color: #28a745; }
        .accessibility-table .ok { color: #ffc107; }
        .accessibility-table .poor { color: #dc3545; }
        .semantic-issues ul, .semantic-recommendations ul { list-style: none; padding-left: 0; margin: 8px 0; }
        .semantic-issues li { padding: 8px 12px; margin: 6px 0; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; }
        .semantic-recommendations li { padding: 8px 12px; margin: 6px 0; background: #d1ecf1; border-left: 3px solid #17a2b8; color: #0c5460; border-radius: 4px; }
        
        footer { text-align: center; color: white; margin-top: 40px; opacity: 0.8; }
        footer a { color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç HTMLens</h1>
            <p class="tagline">Extract semantic knowledge graphs from any webpage</p>
        </header>
        <div class="card">
            <div class="input-section">
                <label for="urlInput">Enter a URL to analyze:</label>
                <input type="url" id="urlInput" placeholder="https://example.com" value="https://schema.org" />
            </div>
            <div class="examples-section">
                <label>Try these examples:</label>
                <div class="example-buttons">
                    <button class="example-btn" data-url="https://kalkhoff-bikes.com/nl_nl/image-5-advance-blx">üö¥ Kalkhoff Bike</button>
                    <button class="example-btn" data-url="https://schema.org">üìö Schema.org</button>
                    <button class="example-btn" data-url="https://www.gazelle.nl">üè™ Gazelle</button>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="analyzeBtn">üöÄ Analyze</button>
                <button class="btn-secondary" id="shareBtn">üîó Share</button>
                <button class="btn-secondary" id="clearBtn">üóëÔ∏è Clear</button>
            </div>
            <div class="loading" id="loading"><div class="spinner"></div><p>Analyzing webpage...</p></div>
            <div class="results" id="results">
                <div class="tabs">
                    <button class="tab active" data-tab="insights">üéØ Insights</button>
                    <button class="tab" data-tab="ai-readiness">ü§ñ AI Readiness</button>
                    <button class="tab" data-tab="summary">üìä Summary</button>
                    <button class="tab" data-tab="jsonld">üóÇÔ∏è JSON-LD</button>
                    <button class="tab" data-tab="structured">üß± Structured Data</button>
                    <button class="tab" data-tab="page">üìÑ Page Content</button>
                </div>
                <div class="tab-content active" id="insights-content">
                    <div id="insightsOutput"></div>
                </div>
                <div class="tab-content" id="ai-readiness-content">
                    <div id="aiReadinessOutput"></div>
                </div>
                <div class="tab-content" id="summary-content">
                    <div class="json-output" id="summaryOutput"></div>
                </div>
                <div class="tab-content" id="jsonld-content">
                    <div class="json-output" id="jsonldOutput"></div>
                </div>
                <div class="tab-content" id="structured-content">
                    <div class="markdown-output" id="structuredOutput"></div>
                </div>
                <div class="tab-content" id="page-content">
                    <div class="markdown-output" id="pageOutput"></div>
                </div>
            </div>
            <div class="error" id="error"><div id="errorMessage"></div></div>
        </div>
        <footer>
            <p>Powered by <a href="https://github.com/pondevelopment/htmlens">htmlens</a> ‚Ä¢ Rust + Cloudflare Workers</p>
            <p>Developed by Pon Datalab</p>
        </footer>
    </div>
    <script>
        const API_BASE = "${origin}";
        
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(targetTab + '-content').classList.add('active');
            });
        });
        
        document.getElementById('analyzeBtn').addEventListener('click', analyze);
        document.getElementById('clearBtn').addEventListener('click', () => {
            document.getElementById('urlInput').value = '';
            document.getElementById('results').classList.remove('active');
            document.getElementById('error').style.display = 'none';
        });
        document.getElementById('shareBtn').addEventListener('click', () => {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) { 
                showError('Please enter a URL to share'); 
                return; 
            }
            
            // Create shareable URL with the analyzed URL as query parameter
            const shareUrl = window.location.origin + window.location.pathname + '?url=' + encodeURIComponent(url);
            
            // Copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Show success feedback
                const btn = document.getElementById('shareBtn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úÖ Copied!';
                btn.style.background = '#28a745';
                btn.style.color = 'white';
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '';
                    btn.style.color = '';
                }, 2000);
            }).catch(err => {
                showError('Failed to copy to clipboard: ' + err.message);
            });
        });
        
        // Handle example button clicks
        document.querySelectorAll('.example-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const url = btn.dataset.url;
                document.getElementById('urlInput').value = url;
                analyze();
            });
        });
        
        // Auto-analyze if URL parameter is present on page load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const urlToAnalyze = urlParams.get('url');
            if (urlToAnalyze) {
                document.getElementById('urlInput').value = urlToAnalyze;
                analyze();
            }
        });
        
        async function analyze() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) { showError('Please enter a URL'); return; }
            
            document.getElementById('error').style.display = 'none';
            document.getElementById('results').classList.remove('active');
            document.getElementById('loading').classList.add('active');
            document.getElementById('analyzeBtn').disabled = true;
            
            try {
                console.log('Fetching:', API_BASE + '/api?url=' + encodeURIComponent(url));
                const response = await fetch(API_BASE + '/api?url=' + encodeURIComponent(url));
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    let errorMessage = 'Failed to analyze';
                    try {
                        const errorData = await response.json();
                        console.log('Error data:', errorData);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error JSON:', e);
                        // If JSON parsing fails, use default error
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                
                // Validate required fields
                if (!data.url || !data.graph || !data.jsonld) {
                    throw new Error('Invalid response structure from API');
                }
                
                // Build Business Summary similar to TypeScript version
                let summary = 'üìä Business Summary\n\n';
                summary += `Page: ${data.url}\n\n`;
                
                // Extract entity types with null checks
                const entityTypes = data.graph.nodes ? [...new Set(data.graph.nodes.flatMap(n => n.types || []))] : [];
                summary += `Content Type: ${entityTypes.join(', ') || 'None detected'}\n\n`;
                
                // Product Information
                const products = data.jsonld.filter(item => 
                    item['@type'] === 'Product' || item['@type'] === 'ProductGroup'
                );
                if (products.length > 0) {
                    const product = products[0];
                    summary += 'üì¶ Product Information\n\n';
                    if (product.name) summary += `${product.name}\n\n`;
                    if (product.brand && product.brand.name) {
                        summary += `Brand: ${product.brand.name}\n`;
                    }
                    if (product.hasVariant) {
                        const variantCount = Array.isArray(product.hasVariant) ? product.hasVariant.length : 1;
                        summary += `Variants Available: ${variantCount}\n`;
                    }
                    summary += '\n';
                }
                
                // Organization
                const orgs = data.jsonld.filter(item => item['@type'] === 'Organization');
                if (orgs.length > 0) {
                    const org = orgs[0];
                    summary += 'üè¢ Organization\n\n';
                    if (org.name) summary += `${org.name}\n`;
                    if (org.url) summary += `${org.url}\n`;
                    summary += '\n';
                }
                
                // Technical Insights
                summary += 'üìã Technical Insights\n\n';
                summary += `Structured Data Blocks: ${data.meta.jsonldCount}\n`;
                summary += `Page Size: ${data.meta.htmlLength.toLocaleString()} characters\n`;
                summary += `SEO Optimization: ‚úÖ Yes (JSON-LD present)\n`;
                
                document.getElementById('summaryOutput').textContent = summary;
                
                    // Update JSON-LD tab with combined @graph structure and syntax highlighting
                    document.getElementById('jsonldOutput').innerHTML = syntaxHighlight(data.jsonldGraph);
                
                // Convert markdown tables to HTML for better display
                document.getElementById('structuredOutput').innerHTML = formatMarkdownTables(data.markdown);
                document.getElementById('pageOutput').textContent = data.pageMarkdown;
                
                // Render insights
                renderInsights(data);
                
                // Render AI readiness
                if (data.aiReadiness) {
                    renderAiReadinessTab(data.url, data.aiReadiness);
                }
                
                document.getElementById('results').classList.add('active');
            } catch (error) {
                console.error('Analysis error:', error);
                showError(error.message || 'An unexpected error occurred');
            } finally {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('analyzeBtn').disabled = false;
            }
        }
        
        function renderAiReadinessTab(url, aiReadiness) {
            let html = '<div class="ai-readiness-container">';
            html += '<h2 style="margin-top: 0;">ü§ñ AI Agent Readiness</h2>';
            html += '<p style="color: #666; margin-bottom: 30px;">Check how well your website communicates with AI agents and chatbots.</p>';
            
            // .well-known files
            html += '<div class="well-known-checks">';
            html += '<h4>üìÅ .well-known Directory</h4>';
            
            // Add comprehensive section introduction
            html += '<div class="section-intro">';
            html += '<p><strong>What is the .well-known directory?</strong></p>';
            html += '<p>The <code>.well-known</code> directory is like a "front desk" for your website where automated systems (AI bots, apps, security researchers) look for important information. It\'s a standardized location (defined by <a href="https://www.rfc-editor.org/rfc/rfc8615.html" target="_blank">Internet Standard RFC 8615</a>) where websites publish machine-readable information.</p>';
            html += '<p style="margin-top: 10px;"><strong>Why does it matter?</strong></p>';
            html += '<p>Think of it like having clear signs at a building entrance. Without these files, AI assistants and apps don\'t know how to interact with your website properly. With them, you unlock advanced features like ChatGPT plugins, app deep-linking, and better security practices.</p>';
            html += '</div>';
            
            html += '<div class="file-checks">';
            
            const checks = [
                { 
                    key: 'aiPluginJson', 
                    label: 'ü§ñ ai-plugin.json (ChatGPT)', 
                    critical: true,
                    docs: 'https://platform.openai.com/docs/plugins/getting-started/plugin-manifest',
                    description: 'ChatGPT plugin manifest for AI integration',
                    explainer: 'Tells ChatGPT how to interact with your website as a plugin. Think of it like an instruction manual for AI assistants.',
                    benefit: 'Your website can become a ChatGPT plugin, allowing millions of users to access your data/services directly through ChatGPT conversations.',
                    impact: 'ChatGPT and other AI assistants won\'t be able to integrate with your website as a plugin. You\'ll miss out on the plugin ecosystem and direct AI-driven traffic.'
                },
                { 
                    key: 'mcpJson', 
                    label: 'üîÆ mcp.json (Claude/MCP)', 
                    critical: true,
                    docs: 'https://modelcontextprotocol.io/',
                    description: 'Model Context Protocol manifest for modern AI agent integration',
                    explainer: 'Allows Claude and other modern AI assistants to understand what data and actions your website offers. Like a menu for AI agents.',
                    benefit: 'Claude AI and MCP-compatible assistants can discover and use your website\'s capabilities automatically. This is the newest standard for AI-website communication.',
                    impact: 'Modern AI assistants like Claude won\'t know how to interact with your site programmatically. You\'ll miss the next wave of AI integration.'
                },
                { 
                    key: 'securityTxt', 
                    label: 'üîí security.txt', 
                    critical: false,
                    docs: 'https://securitytxt.org/',
                    description: 'Security researcher contact information',
                    explainer: 'Provides contact info for security researchers who find vulnerabilities. Like a "found a bug? email us here" sign.',
                    benefit: 'Security researchers know how to responsibly report vulnerabilities. Shows you take security seriously. May help with compliance requirements.',
                    impact: 'Security researchers may not know how to contact you about vulnerabilities, potentially leading to public disclosure or exploitation before you can fix issues.'
                },
                { 
                    key: 'openidConfiguration', 
                    label: 'üîë openid-configuration (OAuth)', 
                    critical: false,
                    docs: 'https://openid.net/specs/openid-connect-discovery-1_0.html',
                    description: 'OAuth/OpenID Connect discovery endpoint',
                    explainer: 'Enables "Sign in with [Your Site]" buttons on other websites. Think "Login with Google" but for your site.',
                    benefit: 'Other websites can offer "Sign in with [Your Brand]" buttons. Users can use your account across multiple sites, increasing engagement and brand reach.',
                    impact: 'You can\'t offer your service as an identity provider. Users won\'t be able to use "Sign in with [Your Brand]" on other sites.'
                },
                { 
                    key: 'appleAppSiteAssociation', 
                    label: 'üì± apple-app-site-association', 
                    critical: false,
                    docs: 'https://developer.apple.com/documentation/xcode/supporting-associated-domains',
                    description: 'iOS Universal Links configuration',
                    explainer: 'Lets links to your website open your mobile app instead (on iOS devices). Like a bridge between your website and iPhone app.',
                    benefit: 'Seamless user experience - clicking website links on iOS opens your app directly. Better engagement and lower abandonment rates.',
                    impact: 'Links to your site will open in Safari instead of your app on iOS. Users have to manually switch to your app, causing friction and potential drop-off.'
                },
                { 
                    key: 'assetlinks', 
                    label: 'ü§ñ assetlinks.json (Android)', 
                    critical: false,
                    docs: 'https://developer.android.com/training/app-links/verify-android-applinks',
                    description: 'Android App Links configuration',
                    explainer: 'Same as above but for Android devices - connects your website links to your Android app.',
                    benefit: 'Android users clicking your links go directly to your app. Creates a unified experience across web and mobile.',
                    impact: 'Links open in Chrome browser instead of your Android app. Fragmented user experience between web and mobile.'
                }
            ];
            
            checks.forEach(check => {
                const file = aiReadiness.wellKnown[check.key];
                const icon = file.found ? '‚úÖ' : '‚ùå';
                const statusText = file.found ? `Found (${file.status})` : `Not found (${file.status})`;
                const criticalClass = check.critical && !file.found ? 'critical-missing' : '';
                html += `<div class="file-check ${criticalClass}">`;
                html += `<div>${icon} <strong>${check.label}</strong>: ${statusText}`;
                if (file.valid === false) html += ' <span class="invalid">(Invalid JSON)</span>';
                html += '</div>';
                
                // Add link to the actual file if found
                if (file.found) {
                    const wellKnownUrl = url.replace(/\/$/, '') + '/.well-known/' + check.key.replace('Json', '.json').replace('Configuration', '-configuration').replace('Txt', '.txt').replace('Association', '-association');
                    html += `<div class="file-link">üîó <a href="${wellKnownUrl}" target="_blank">View file</a></div>`;
                }
                
                html += `<div class="file-check-description"><strong>What it does:</strong> ${check.explainer}</div>`;
                
                // Show benefit when found, or impact when not found
                if (file.found) {
                    html += `<div class="benefit-box"><strong>‚úÖ Benefit:</strong> ${check.benefit}</div>`;
                } else {
                    html += `<div class="impact-box"><strong>‚ö†Ô∏è Impact of not having this:</strong> ${check.impact}</div>`;
                }
                
                html += `<div class="file-check-description" style="font-size: 12px; margin-top: 4px;">Technical: ${check.description} - <a href="${check.docs}" target="_blank">Learn more ‚Üí</a></div>`;
                html += '</div>';
            });
            
            html += '</div></div>';
            
            // AI Plugin status
            if (aiReadiness.aiPlugin) {
                const plugin = aiReadiness.aiPlugin;
                html += '<div class="ai-plugin-status">';
                html += '<h4>üéØ AI Plugin Manifest (OpenAI) <a href="https://platform.openai.com/docs/plugins" target="_blank" class="docs-link">üìö Docs</a></h4>';
                
                html += '<div class="explainer-box">';
                html += '<p><strong>What is this?</strong> Your website has a ChatGPT plugin configuration file! This means ChatGPT can interact with your website\'s API directly.</p>';
                html += '<p style="margin-top: 8px;"><strong>Real-world example:</strong> Users chatting with ChatGPT can say "search for products on [your site]" and ChatGPT will fetch real-time data from your website and display it in the conversation.</p>';
                html += '</div>';
                
                html += `<div><strong>Plugin Name:</strong> ${plugin.name}</div>`;
                html += `<div><strong>Description:</strong> ${plugin.description}</div>`;
                html += `<div><strong>Authentication:</strong> ${plugin.hasAuth ? 'üîí Required (more secure)' : 'üîì None (public access)'}</div>`;
                if (plugin.apiUrl) {
                    html += `<div><strong>API Endpoint:</strong> <a href="${plugin.apiUrl}" target="_blank">${plugin.apiUrl}</a></div>`;
                    html += '<div class="benefit-box"><strong>‚úÖ What this enables:</strong> ChatGPT users can directly access your data and services without leaving the conversation. This creates a new channel for customer engagement and can drive traffic to your services.</div>';
                }
                if (plugin.issues.length > 0) {
                    html += '<div class="plugin-issues"><strong>‚ö†Ô∏è Configuration Issues:</strong> ' + plugin.issues.join(', ') + '</div>';
                    html += '<div class="impact-box"><strong>Impact:</strong> These issues may prevent ChatGPT from properly connecting to your API. Fix them to ensure smooth integration.</div>';
                }
                html += '<div class="section-footer">Learn how to create ChatGPT plugins at <a href="https://platform.openai.com/docs/plugins/getting-started" target="_blank">OpenAI Platform ‚Üí</a></div>';
                html += '</div>';
            }
            
            // MCP status
            if (aiReadiness.mcp) {
                const mcp = aiReadiness.mcp;
                html += '<div class="mcp-status">';
                html += '<h4>üîÆ Model Context Protocol (Anthropic) <a href="https://modelcontextprotocol.io/" target="_blank" class="docs-link">üìö Docs</a></h4>';
                
                html += '<div class="explainer-box">';
                html += '<p><strong>What is this?</strong> Your website supports the Model Context Protocol (MCP) - the newest standard for AI-website communication developed by Anthropic (makers of Claude AI).</p>';
                html += '<p style="margin-top: 8px;"><strong>Why it matters:</strong> MCP is like USB-C for AI integration - a universal standard that will work with many future AI assistants. It\'s more flexible and powerful than older plugin systems.</p>';
                html += '<p style="margin-top: 8px;"><strong>Real example:</strong> Claude AI can read your documentation, access your data, or perform actions on your site - all through this standardized protocol.</p>';
                html += '</div>';
                
                html += `<div><strong>Server Name:</strong> ${mcp.name}</div>`;
                html += `<div><strong>Version:</strong> ${mcp.version} (Protocol: ${mcp.protocolVersion})</div>`;
                html += `<div><strong>Connection:</strong> ${mcp.transportType} endpoint at <code>${mcp.endpoint}</code></div>`;
                
                html += '<div class="mcp-capabilities">';
                html += '<strong>üõ†Ô∏è What AI Assistants Can Do:</strong>';
                html += '<ul>';
                if (mcp.hasToolsCapability) {
                    html += `<li>‚úÖ <strong>Execute ${mcp.toolCount} Tools</strong> - AI can perform actions like searching, creating, or updating data</li>`;
                }
                if (mcp.hasResourcesCapability) {
                    html += `<li>‚úÖ <strong>Access ${mcp.resourceCount} Resources</strong> - AI can read your data, documents, or content</li>`;
                }
                if (mcp.hasPromptsCapability) {
                    html += `<li>‚úÖ <strong>Use ${mcp.promptCount} Prompts</strong> - Pre-configured AI instructions for common tasks</li>`;
                }
                if (mcp.hasEventsCapability) {
                    html += `<li>‚úÖ <strong>Receive Events</strong> - AI can be notified when things change on your site</li>`;
                }
                if (!mcp.hasToolsCapability && !mcp.hasResourcesCapability && !mcp.hasPromptsCapability && !mcp.hasEventsCapability) {
                    html += '<li>‚ö†Ô∏è No capabilities declared - MCP server may not be fully configured</li>';
                }
                html += '</ul>';
                html += '</div>';
                
                html += '<div class="benefit-box"><strong>‚úÖ Benefits:</strong> Future-proof AI integration. Works with Claude AI now and will work with other MCP-compatible assistants. More powerful than simple API access - AI can understand context and perform complex workflows.</div>';
                
                if (mcp.healthEndpoint) html += `<div><strong>Health Monitor:</strong> <a href="${mcp.healthEndpoint}" target="_blank">${mcp.healthEndpoint}</a> - Check if the server is running</div>`;
                
                if (mcp.issues.length > 0) {
                    html += '<div class="mcp-issues"><strong>‚ö†Ô∏è Configuration Issues:</strong> ' + mcp.issues.join(', ') + '</div>';
                    html += '<div class="impact-box"><strong>Impact:</strong> These issues may prevent AI assistants from connecting properly. Review your MCP configuration.</div>';
                }
                html += '<div class="section-footer">Learn about MCP at <a href="https://modelcontextprotocol.io/" target="_blank">MCP Documentation ‚Üí</a> or <a href="https://www.anthropic.com/news/model-context-protocol" target="_blank">Anthropic Announcement</a></div>';
                html += '</div>';
            }
            
            // OpenAPI status
            if (aiReadiness.openapi) {
                const api = aiReadiness.openapi;
                html += '<div class="openapi-status">';
                html += '<h4>üì° OpenAPI Specification <a href="https://swagger.io/specification/" target="_blank" class="docs-link">üìö Docs</a></h4>';
                
                html += '<div class="explainer-box">';
                html += '<p><strong>What is this?</strong> Your website provides an OpenAPI specification - a machine-readable document that describes your entire API (what data is available, what actions can be performed, what format to use).</p>';
                html += '<p style="margin-top: 8px;"><strong>Why it matters:</strong> Like a menu at a restaurant, this tells AI assistants exactly what they can order from your API, how to order it, and what they\'ll get back.</p>';
                html += '<p style="margin-top: 8px;"><strong>Real example:</strong> An AI assistant can automatically discover that your API has a "search products" endpoint, understand it needs a query parameter, and know it returns JSON with product details.</p>';
                html += '</div>';
                
                html += `<div><strong>Specification Version:</strong> OpenAPI ${api.version}</div>`;
                html += `<div><strong>API Operations:</strong> ${api.operationCount} endpoints documented</div>`;
                html += `<div><strong>Security:</strong> ${api.hasAuth ? '‚úÖ Authentication configured' : '‚ö†Ô∏è No authentication specified'}</div>`;
                
                html += '<div class="benefit-box"><strong>‚úÖ Benefits:</strong> AI assistants can automatically understand and use your API without manual coding. Reduces integration time from days to minutes. Works with ChatGPT plugins, Claude tools, and any OpenAPI-compatible system.</div>';
                
                if (api.issues.length > 0) {
                    html += '<div class="api-issues"><strong>‚ö†Ô∏è Specification Issues:</strong> ' + api.issues.join(', ') + '</div>';
                    html += '<div class="impact-box"><strong>Impact:</strong> These issues may prevent AI from correctly understanding or using your API. Validate your OpenAPI spec using tools like <a href="https://editor.swagger.io/" target="_blank">Swagger Editor</a>.</div>';
                }
                
                html += '<div class="section-footer">Learn about OpenAPI at <a href="https://www.openapis.org/" target="_blank">OpenAPI Initiative ‚Üí</a> or validate at <a href="https://editor.swagger.io/" target="_blank">Swagger Editor</a></div>';
                html += '</div>';
            }
            
            // Robots.txt status
            if (aiReadiness.robotsTxt) {
                const robots = aiReadiness.robotsTxt;
                html += '<div class="robots-txt-status">';
                html += '<h4>ü§ñ robots.txt Analysis <a href="https://developers.google.com/search/docs/crawling-indexing/robots/intro" target="_blank" class="docs-link">üìö Docs</a></h4>';
                
                html += '<div class="explainer-box">';
                html += '<p><strong>What is robots.txt?</strong> A simple text file that tells search engines and AI bots which parts of your website they can visit. Like a "no entry" sign for automated visitors.</p>';
                html += '<p style="margin-top: 8px;"><strong>Why it matters:</strong> You can protect private areas (like admin pages), save bandwidth by blocking unnecessary bots, or invite specific AI crawlers to learn from your public content.</p>';
                html += '<p style="margin-top: 8px;"><strong>Real example:</strong> "Allow ChatGPT to read my blog posts, but block all bots from my customer login pages"</p>';
                html += '</div>';
                
                if (robots.found) {
                    html += `<div><strong>Status:</strong> ‚úÖ Found at <a href="${robots.url || (window.location.origin + '/robots.txt')}" target="_blank" class="file-link">/robots.txt</a></div>`;
                    html += `<div><strong>Sitemap References:</strong> ${robots.sitemapCount} sitemap(s) listed</div>`;
                    
                    if (robots.sitemaps.length > 0) {
                        html += '<div class="sitemap-list"><strong>üìç Sitemaps Found:</strong>';
                        html += '<div class="explainer-box" style="margin-top: 8px;">Listing sitemaps here tells crawlers where to find all your pages. Saves them time and ensures they don\'t miss important content.</div>';
                        html += '<ul>';
                        robots.sitemaps.forEach(sitemap => {
                            html += `<li><a href="${sitemap}" target="_blank" class="file-link">${sitemap}</a></li>`;
                        });
                        html += '</ul></div>';
                    }
                    
                    if (robots.blocksAllBots) {
                        html += '<div class="robots-warning">‚ö†Ô∏è <strong>Warning:</strong> All bots are blocked (Disallow: /)</div>';
                        html += '<div class="impact-box"><strong>Impact:</strong> Your website is invisible to search engines and AI assistants. No one can find your content through Google, ChatGPT, or other services. This is typically only intended for development/staging sites.</div>';
                    } else {
                        html += '<div class="benefit-box"><strong>‚úÖ Good Configuration:</strong> Your robots.txt is properly configured to allow appropriate bot access.</div>';
                    }
                    
                    // AI Crawler table
                    html += '<div class="ai-crawlers-section" style="margin-top: 20px;">';
                    html += '<strong>ü§ñ AI Crawler Access Control:</strong>';
                    html += '<div class="explainer-box" style="margin-top: 8px; margin-bottom: 12px;">These are the major AI bots that might visit your website to learn about your content for answering user questions. Each one represents a different AI assistant (ChatGPT, Claude, Perplexity, etc.).</div>';
                    html += '<table class="ai-crawlers-table">';
                    html += '<thead><tr><th>Crawler</th><th>Access Status</th><th>Rules Applied</th></tr></thead>';
                    html += '<tbody>';
                    
                    const botDescriptions = {
                        'GPTBot': 'OpenAI\'s web crawler that gathers data for ChatGPT and GPT models',
                        'ChatGPT-User': 'When ChatGPT users browse the web through ChatGPT (Browse with Bing feature)',
                        'ClaudeBot': 'Anthropic\'s web crawler that gathers data for Claude AI assistant',
                        'Claude-Web': 'When Claude users request web content through Claude',
                        'Google-Extended': 'Google\'s crawler for training AI models (separate from regular search)',
                        'Bingbot': 'Microsoft\'s main search crawler, also used for Copilot AI',
                        'Applebot': 'Apple\'s crawler for Siri and Spotlight search',
                        'PerplexityBot': 'Perplexity AI\'s crawler for their AI-powered search engine'
                    };
                    
                    robots.aiCrawlers.forEach((crawler, index) => {
                        const accessIcon = crawler.access === 'allowed' ? '‚úÖ' : 
                                         crawler.access === 'blocked' ? '‚ùå' : 
                                         crawler.access === 'partial' ? '‚ö†Ô∏è' : '‚ûñ';
                        const accessClass = `access-${crawler.access}`;
                        html += `<tr class="${accessClass}">`;
                        html += `<td><strong>${crawler.name}</strong><div class="bot-description">${botDescriptions[crawler.name] || 'AI crawler bot'}</div></td>`;
                        html += `<td>${accessIcon} ${crawler.access.charAt(0).toUpperCase() + crawler.access.slice(1)}</td>`;
                        html += `<td>`;
                        if (crawler.rules) {
                            const rulesId = `rules-${index}`;
                            html += `<span class="collapsible-rules" onclick="toggleRules('${rulesId}')">View rules ‚ñº</span>`;
                            html += `<div id="${rulesId}" class="rules-detail">${crawler.rules.split(';').join('<br>')}</div>`;
                        } else {
                            html += 'Default (all paths allowed)';
                        }
                        html += `</td>`;
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    html += '</div>';
                    
                    if (robots.issues.length > 0) {
                        html += '<div class="robots-issues" style="margin-top: 15px;">';
                        html += '<strong>‚ö†Ô∏è Configuration Issues:</strong><ul>';
                        robots.issues.forEach(issue => {
                            html += `<li>${issue}</li>`;
                        });
                        html += '</ul></div>';
                        html += '<div class="impact-box"><strong>Impact:</strong> These issues may cause unexpected bot behavior or misinterpretation of your access rules.</div>';
                    }
                } else {
                    html += '<div>‚ùå <strong>robots.txt not found</strong></div>';
                    html += '<div class="impact-box"><strong>Impact:</strong> Without robots.txt, you can\'t control which bots visit your site or protect sensitive areas. All bots will try to crawl everything, which may waste bandwidth or expose pages you don\'t want indexed.</div>';
                    html += '<div class="benefit-box" style="margin-top: 10px;"><strong>Recommendation:</strong> Create a robots.txt file to:<br>‚Ä¢ List your sitemap(s) so bots find all your content<br>‚Ä¢ Block AI bots from private or low-value pages<br>‚Ä¢ Invite specific AI assistants to learn from your public content</div>';
                }
                
                html += '<div class="section-footer">Learn about robots.txt at <a href="https://developers.google.com/search/docs/crawling-indexing/robots/intro" target="_blank">Google Search Central ‚Üí</a> or <a href="https://www.robotstxt.org/" target="_blank">robotstxt.org</a></div>';
                html += '</div>';
            }
            
            // Sitemap section
            if (aiReadiness.sitemap) {
                const sitemap = aiReadiness.sitemap;
                html += '<div class="sitemap-status">';
                html += '<h3>üó∫Ô∏è XML Sitemap Analysis</h3>';
                
                html += '<div class="explainer-box">';
                html += '<p><strong>What is a sitemap?</strong> An XML file that lists all important pages on your website, like a table of contents for a book. Helps search engines and AI bots find all your content efficiently.</p>';
                html += '<p style="margin-top: 8px;"><strong>Why it matters:</strong> Without a sitemap, bots have to discover your pages by clicking links. They might miss important content, especially new pages or deep content. A sitemap is like handing them a complete map upfront.</p>';
                html += '<p style="margin-top: 8px;"><strong>Real example:</strong> An e-commerce site with 10,000 products - the sitemap ensures Google and AI bots find every single product page, not just the ones linked from the homepage.</p>';
                html += '</div>';
                
                if (sitemap.found) {
                    html += `<div><strong>Status:</strong> ‚úÖ Found at <a href="${sitemap.url || (window.location.origin + '/sitemap.xml')}" target="_blank" class="file-link">/sitemap.xml</a></div>`;
                    html += `<div><strong>Type:</strong> ${sitemap.sitemapType === 'index' ? 'üìë Sitemap Index (contains multiple sitemaps)' : 'üìÑ Standard Sitemap'}</div>`;
                    html += `<div><strong>Total URLs:</strong> ${sitemap.urlCount.toLocaleString()} pages listed</div>`;
                    
                    if (sitemap.lastModified) {
                        html += `<div><strong>Last Modified:</strong> ${sitemap.lastModified}</div>`;
                    }
                    
                    html += '<div class="benefit-box" style="margin-top: 12px;"><strong>‚úÖ Great!</strong> Your sitemap helps bots find all ' + sitemap.urlCount.toLocaleString() + ' pages efficiently. They don\'t have to waste time clicking through your entire site.</div>';
                    
                    // Statistics
                    if (sitemap.statistics.totalUrls > 0) {
                        html += '<div class="sitemap-stats" style="margin-top: 20px;">';
                        html += '<h4>üìä Sitemap Quality Metrics</h4>';
                        html += '<div class="explainer-box">These metrics show how well-structured your sitemap is. More metadata = better guidance for bots.</div>';
                        html += '<table class="sitemap-stats-table">';
                        
                        const datePercent = Math.round(sitemap.statistics.urlsWithLastmod / sitemap.statistics.totalUrls * 100);
                        html += '<tr><td><strong>URLs with dates</strong><br><small>Last modified timestamps</small></td><td>' + sitemap.statistics.urlsWithLastmod + ' (' + datePercent + '%)</td></tr>';
                        if (datePercent < 50) {
                            html += '<tr><td colspan="2" class="impact-box"><strong>Impact:</strong> Only ' + datePercent + '% of URLs have modification dates. Bots can\'t tell which pages are fresh vs. stale. Add &lt;lastmod&gt; tags to help them prioritize.</td></tr>';
                        }
                        
                        const priorityPercent = Math.round(sitemap.statistics.urlsWithPriority / sitemap.statistics.totalUrls * 100);
                        html += '<tr><td><strong>URLs with priority</strong><br><small>Importance ranking (0.0-1.0)</small></td><td>' + sitemap.statistics.urlsWithPriority + ' (' + priorityPercent + '%)</td></tr>';
                        if (priorityPercent < 50) {
                            html += '<tr><td colspan="2" class="impact-box"><strong>Impact:</strong> Only ' + priorityPercent + '% of URLs have priority values. Bots don\'t know which pages are most important. Add &lt;priority&gt; tags (0.8+ for key pages, 0.5 for regular content).</td></tr>';
                        }
                        
                        if (sitemap.statistics.avgPriority > 0) {
                            html += '<tr><td><strong>Average priority</strong><br><small>Should be around 0.5 (balanced)</small></td><td>' + sitemap.statistics.avgPriority.toFixed(2) + '</td></tr>';
                            if (sitemap.statistics.avgPriority > 0.8) {
                                html += '<tr><td colspan="2" class="impact-box"><strong>Warning:</strong> Average priority is very high (' + sitemap.statistics.avgPriority.toFixed(2) + '). When everything is "important", nothing is. Use lower priorities (0.5) for regular pages.</td></tr>';
                            }
                        }
                        
                        html += '</table>';
                        html += '</div>';
                    }
                    
                    // Content type distribution
                    if (sitemap.statistics.contentTypes && Object.keys(sitemap.statistics.contentTypes).length > 0) {
                        html += '<div class="content-types" style="margin-top: 20px;">';
                        html += '<h4>üìÅ Content Type Distribution</h4>';
                        html += '<div class="explainer-box">We detected what types of pages are in your sitemap by analyzing the URLs. This helps understand your site\'s content structure.</div>';
                        html += '<table class="content-types-table">';
                        const sortedTypes = Object.entries(sitemap.statistics.contentTypes).sort((a, b) => b[1] - a[1]);
                        sortedTypes.forEach(([type, count]) => {
                            const icon = type === 'product' ? 'üõçÔ∏è' : type === 'blog' ? 'üìù' : type === 'article' ? 'üì∞' : type === 'documentation' ? 'üìö' : 'üìÑ';
                            const percent = Math.round(count / sitemap.statistics.totalUrls * 100);
                            html += `<tr><td>${icon} <strong>${type.charAt(0).toUpperCase() + type.slice(1)}</strong></td><td>${count.toLocaleString()} URLs (${percent}%)</td></tr>`;
                        });
                        html += '</table>';
                        html += '</div>';
                    }
                    
                    // Nested sitemaps (for sitemap index)
                    if (sitemap.nestedSitemaps && sitemap.nestedSitemaps.length > 0) {
                        html += '<div class="nested-sitemaps" style="margin-top: 20px;">';
                        html += '<h4>üìë Nested Sitemaps</h4>';
                        html += '<div class="explainer-box">Your sitemap is organized into multiple files (a "sitemap index"). This is great for large sites - keeps files small and organized by content type.</div>';
                        html += '<ul class="sitemap-list">';
                        sitemap.nestedSitemaps.forEach(url => {
                            html += `<li><a href="${url}" target="_blank" class="file-link">${url}</a></li>`;
                        });
                        html += '</ul>';
                        html += '</div>';
                    }
                    
                    // Sample URLs (for standard sitemaps)
                    if (sitemap.sampleUrls && sitemap.sampleUrls.length > 0) {
                        html += '<div class="sample-urls" style="margin-top: 20px;">';
                        html += '<h4>üîç Sample URLs (first 10)</h4>';
                        html += '<div class="explainer-box">A preview of the pages in your sitemap. Check that the most important pages are included with recent dates and appropriate priorities.</div>';
                        html += '<table class="sample-urls-table">';
                        html += '<thead><tr><th>URL</th><th>Last Modified</th><th>Priority</th></tr></thead>';
                        html += '<tbody>';
                        sitemap.sampleUrls.forEach(url => {
                            const shortUrl = url.loc.length > 60 ? url.loc.substring(0, 57) + '...' : url.loc;
                            html += '<tr>';
                            html += `<td><a href="${url.loc}" target="_blank" title="${url.loc}">${shortUrl}</a></td>`;
                            html += `<td>${url.lastmod || '<span style="color: #999;">-</span>'}</td>`;
                            html += `<td>${url.priority !== null ? url.priority.toFixed(1) : '<span style="color: #999;">-</span>'}</td>`;
                            html += '</tr>';
                        });
                        html += '</tbody>';
                        html += '</table>';
                        html += '</div>';
                    }
                    
                    // Issues
                    if (sitemap.issues && sitemap.issues.length > 0) {
                        html += '<div class="sitemap-issues" style="margin-top: 20px;">';
                        html += '<h4>‚ö†Ô∏è Issues Detected</h4>';
                        html += '<ul>';
                        sitemap.issues.forEach(issue => {
                            html += `<li>${issue}</li>`;
                        });
                        html += '</ul>';
                        html += '<div class="impact-box"><strong>Impact:</strong> These issues may prevent bots from reading your sitemap correctly or cause them to skip some pages.</div>';
                        html += '</div>';
                    }
                    
                    // Recommendations
                    if (sitemap.recommendations && sitemap.recommendations.length > 0) {
                        html += '<div class="sitemap-recommendations" style="margin-top: 20px;">';
                        html += '<h4>üí° Optimization Tips</h4>';
                        html += '<ul>';
                        sitemap.recommendations.forEach(rec => {
                            html += `<li>${rec}</li>`;
                        });
                        html += '</ul>';
                        html += '</div>';
                    }
                } else {
                    html += '<div>‚ùå <strong>Sitemap not found</strong></div>';
                    html += '<div class="impact-box"><strong>Impact:</strong> Search engines and AI bots must discover your pages by clicking links. They might miss important content, especially:<br>‚Ä¢ New pages that aren\'t well-linked yet<br>‚Ä¢ Deep content (4+ clicks from homepage)<br>‚Ä¢ Pages only accessible through search/filters<br>‚Ä¢ Dynamically generated pages</div>';
                    html += '<div class="benefit-box" style="margin-top: 12px;"><strong>Recommendation:</strong> Create a sitemap.xml file to:<br>‚Ä¢ Help bots find all your content immediately<br>‚Ä¢ Show which pages were recently updated (they crawl those first)<br>‚Ä¢ Indicate which pages are most important<br>‚Ä¢ Improve SEO and AI discoverability by 30-50% for large sites</div>';
                }
                
                html += '<div class="section-footer">Learn about sitemaps at <a href="https://developers.google.com/search/docs/crawling-indexing/sitemaps/overview" target="_blank">Google Search Central ‚Üí</a> or use <a href="https://www.xml-sitemaps.com/" target="_blank">sitemap generators</a></div>';
                html += '</div>';
            }
            
            // Semantic HTML section
            if (aiReadiness.semanticHtml) {
                const semantic = aiReadiness.semanticHtml;
                html += '<div class="semantic-html-status">';
                html += '<h3>üèóÔ∏è Semantic HTML & Accessibility</h3>';
                
                html += '<div class="explainer-box">';
                html += '<p><strong>What is Semantic HTML?</strong> Using the right HTML tags that describe what content IS, not just how it looks. Instead of generic &lt;div&gt; tags everywhere, use meaningful tags like &lt;nav&gt; for navigation, &lt;article&gt; for articles, &lt;header&gt; for headers.</p>';
                html += '<p style="margin-top: 8px;"><strong>Why it matters:</strong> Helps screen readers for visually impaired users navigate your site. Helps AI assistants understand your page structure ("this is the main content, this is navigation"). Improves SEO by making content meaning clear.</p>';
                html += '<p style="margin-top: 8px;"><strong>Real example:</strong> A screen reader can announce "entering navigation" and let users jump directly to main content, skipping the menu. AI can extract the article content without including navigation links.</p>';
                html += '</div>';
                
                // Landmarks
                html += '<div class="landmarks-section" style="margin-top: 20px;">';
                html += '<h4>üó∫Ô∏è Page Landmarks (Navigation Shortcuts)</h4>';
                html += '<div class="explainer-box">Landmarks are special HTML tags that mark major page sections. Screen reader users can jump between landmarks instantly (like pressing "skip to main content"). AI tools use these to identify page structure.</div>';
                html += '<div class="landmarks-grid" style="margin-top: 10px;">';
                html += `<div class="landmark-item">${semantic.landmarks.hasMain ? '‚úÖ' : '‚ùå'} <strong>Main content</strong> <code>&lt;main&gt;</code><br><small>${semantic.landmarks.hasMain ? 'Found - marks primary page content' : 'Missing - add &lt;main&gt; around your main content'}</small></div>`;
                html += `<div class="landmark-item">${semantic.landmarks.hasNavigation ? '‚úÖ' : '‚ùå'} <strong>Navigation</strong> <code>&lt;nav&gt;</code><br><small>${semantic.landmarks.hasNavigation ? 'Found - marks site navigation' : 'Missing - wrap menus in &lt;nav&gt;'}</small></div>`;
                html += `<div class="landmark-item">${semantic.landmarks.hasHeader ? '‚úÖ' : '‚ùå'} <strong>Header</strong> <code>&lt;header&gt;</code><br><small>${semantic.landmarks.hasHeader ? 'Found - marks page/section header' : 'Missing - use &lt;header&gt; for page top'}</small></div>`;
                html += `<div class="landmark-item">${semantic.landmarks.hasFooter ? '‚úÖ' : '‚ùå'} <strong>Footer</strong> <code>&lt;footer&gt;</code><br><small>${semantic.landmarks.hasFooter ? 'Found - marks page footer' : 'Missing - use &lt;footer&gt; for page bottom'}</small></div>`;
                if (semantic.landmarks.articleCount > 0) {
                    html += `<div class="landmark-item">‚úÖ <strong>${semantic.landmarks.articleCount} Article(s)</strong><br><small>Self-contained content pieces</small></div>`;
                }
                html += '</div>';
                
                const missingLandmarks = [];
                if (!semantic.landmarks.hasMain) missingLandmarks.push('&lt;main&gt;');
                if (!semantic.landmarks.hasNavigation) missingLandmarks.push('&lt;nav&gt;');
                if (!semantic.landmarks.hasHeader) missingLandmarks.push('&lt;header&gt;');
                if (!semantic.landmarks.hasFooter) missingLandmarks.push('&lt;footer&gt;');
                
                if (missingLandmarks.length > 0) {
                    html += '<div class="impact-box" style="margin-top: 10px;"><strong>Impact of missing landmarks:</strong> Screen reader users can\'t quickly jump to different sections. AI tools may struggle to identify your main content vs. navigation/ads. Consider adding: ' + missingLandmarks.join(', ') + '</div>';
                } else {
                    html += '<div class="benefit-box" style="margin-top: 10px;"><strong>‚úÖ Excellent!</strong> All key landmarks present. Screen readers can navigate efficiently, and AI can clearly identify page structure.</div>';
                }
                html += '</div>';
                
                // Headings
                html += '<div class="headings-section" style="margin-top: 20px;">';
                html += '<h4>üìë Heading Structure (Content Outline)</h4>';
                html += '<div class="explainer-box">Headings (&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;...) create an outline of your page, like chapters in a book. They should be in order (h1 ‚Üí h2 ‚Üí h3) without skipping levels. Screen readers use this to build a table of contents.</div>';
                html += `<div style="margin-top: 10px;">${semantic.headings.hasSingleH1 ? '‚úÖ' : '‚ö†Ô∏è'} <strong>${semantic.headings.hasSingleH1 ? 'Single &lt;h1&gt; (Perfect)' : 'Multiple or Missing &lt;h1&gt;'}</strong><br><small>${semantic.headings.hasSingleH1 ? 'Your page has exactly one main title' : 'Page should have exactly one &lt;h1&gt; (the main title). Multiple h1s confuse hierarchy.'}</small></div>`;
                html += `<div style="margin-top: 10px;">${semantic.headings.properHierarchy ? '‚úÖ' : '‚ö†Ô∏è'} <strong>${semantic.headings.properHierarchy ? 'Proper Hierarchy (No Skips)' : 'Hierarchy Has Gaps'}</strong><br><small>${semantic.headings.properHierarchy ? 'Headings follow proper order (no skipped levels)' : 'Don\'t skip levels (e.g., h1 ‚Üí h3). Go h1 ‚Üí h2 ‚Üí h3 in order.'}</small></div>`;
                html += '<div class="heading-distribution" style="margin-top: 10px;"><strong>Your heading distribution:</strong> ';
                semantic.headings.distribution.forEach((count, index) => {
                    if (count > 0) {
                        html += `<span class="heading-badge">h${index + 1}: ${count}</span> `;
                    }
                });
                html += '</div>';
                
                if (!semantic.headings.hasSingleH1 || !semantic.headings.properHierarchy) {
                    html += '<div class="impact-box" style="margin-top: 10px;"><strong>Impact:</strong> Broken heading hierarchy makes it harder for screen readers to navigate and AI to understand your content structure. Fix by using exactly one h1, then h2s for main sections, h3s for subsections, etc.</div>';
                } else {
                    html += '<div class="benefit-box" style="margin-top: 10px;"><strong>‚úÖ Great structure!</strong> Your headings create a clear content hierarchy that both humans and AI can follow easily.</div>';
                }
                html += '</div>';
                
                // Forms & Images
                if (semantic.forms.totalInputs > 0 || semantic.images.totalImages > 0) {
                    html += '<div class="accessibility-section" style="margin-top: 20px;">';
                    html += '<h4>‚ôø Accessibility for Users with Disabilities</h4>';
                    html += '<div class="explainer-box">Makes your website usable for people with disabilities (blindness, motor impairments, etc.) and helps AI understand your content better. Alt text describes images for blind users. Labels connect form fields to their descriptions.</div>';
                    html += '<table class="accessibility-table" style="margin-top: 10px;">';
                    
                    if (semantic.forms.totalInputs > 0) {
                        const formClass = semantic.forms.labelPercentage >= 90 ? 'good' : semantic.forms.labelPercentage >= 70 ? 'ok' : 'poor';
                        const formIcon = semantic.forms.labelPercentage >= 90 ? '‚úÖ' : semantic.forms.labelPercentage >= 70 ? '‚ö†Ô∏è' : '‚ùå';
                        html += '<tr>';
                        html += `<td><strong>Form Inputs with Labels</strong><br><small>Labels tell users (and AI) what each form field is for</small></td>`;
                        html += `<td class="${formClass}">${formIcon} ${semantic.forms.labeledInputs}/${semantic.forms.totalInputs} (${semantic.forms.labelPercentage}%)</td>`;
                        html += '</tr>';
                        if (semantic.forms.labelPercentage < 90) {
                            html += '<tr><td colspan="2" class="impact-box"><strong>Impact:</strong> ' + (semantic.forms.totalInputs - semantic.forms.labeledInputs) + ' form field(s) have no label. Screen reader users won\'t know what to enter. Add &lt;label for="fieldId"&gt; tags.</td></tr>';
                        }
                    }
                    
                    if (semantic.images.totalImages > 0) {
                        const imgClass = semantic.images.altPercentage >= 90 ? 'good' : semantic.images.altPercentage >= 70 ? 'ok' : 'poor';
                        const imgIcon = semantic.images.altPercentage >= 90 ? '‚úÖ' : semantic.images.altPercentage >= 70 ? '‚ö†Ô∏è' : '‚ùå';
                        html += '<tr>';
                        html += `<td><strong>Images with Alt Text</strong><br><small>Alt text describes images for blind users and AI</small></td>`;
                        html += `<td class="${imgClass}">${imgIcon} ${semantic.images.imagesWithAlt}/${semantic.images.totalImages} (${semantic.images.altPercentage}%)</td>`;
                        html += '</tr>';
                        if (semantic.images.altPercentage < 90) {
                            html += '<tr><td colspan="2" class="impact-box"><strong>Impact:</strong> ' + (semantic.images.totalImages - semantic.images.imagesWithAlt) + ' image(s) have no alt text. Blind users hear "image" with no context. Add alt="description" to all images (use alt="" for decorative images).</td></tr>';
                        }
                    }
                    
                    html += '</table>';
                    if (semantic.forms.labelPercentage >= 90 && semantic.images.altPercentage >= 90) {
                        html += '<div class="benefit-box" style="margin-top: 10px;"><strong>‚úÖ Excellent accessibility!</strong> Your forms and images are properly labeled, making your site usable for everyone.</div>';
                    }
                    html += '</div>';
                }
                
                // Issues
                if (semantic.issues && semantic.issues.length > 0) {
                    html += '<div class="semantic-issues" style="margin-top: 20px;">';
                    html += '<h4>‚ö†Ô∏è Issues Found</h4>';
                    html += '<ul>';
                    semantic.issues.forEach(issue => {
                        html += `<li>${issue}</li>`;
                    });
                    html += '</ul>';
                    html += '<div class="impact-box"><strong>Overall Impact:</strong> These issues make your site harder to use for people with disabilities and harder for AI to understand. Fixing them improves accessibility and SEO.</div>';
                    html += '</div>';
                }
                
                // Recommendations
                if (semantic.recommendations && semantic.recommendations.length > 0) {
                    html += '<div class="semantic-recommendations" style="margin-top: 20px;">';
                    html += '<h4>üí° Recommendations</h4>';
                    html += '<ul>';
                    semantic.recommendations.forEach(rec => {
                        html += `<li>${rec}</li>`;
                    });
                    html += '</ul>';
                    html += '</div>';
                }
                
                html += '<div class="section-footer">Used by AI-enabled browsers, screen readers, and voice assistants ‚Ä¢ Learn more at <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" target="_blank">MDN Web Docs ‚Üí</a></div>';
                html += '</div>';
            }
            
            // General resources section
            html += '<div class="ai-resources">';
            html += '<h4>üìö Additional Resources</h4>';
            html += '<ul>';
            html += '<li><a href="https://www.rfc-editor.org/rfc/rfc8615.html" target="_blank">RFC 8615: Well-Known URIs</a> - Official specification for .well-known directory</li>';
            html += '<li><a href="https://ai.google.dev/gemini-api/docs/plugins" target="_blank">Google Gemini Plugins</a> - AI plugin integration for Google\'s Gemini</li>';
            html += '<li><a href="https://learn.microsoft.com/en-us/semantic-kernel/" target="_blank">Microsoft Semantic Kernel</a> - AI orchestration framework</li>';
            html += '<li><a href="https://developers.cloudflare.com/ai/" target="_blank">Cloudflare AI</a> - AI tools and Workers AI platform</li>';
            html += '</ul>';
            html += '</div>';
            
            html += '</div>';
            document.getElementById('aiReadinessOutput').innerHTML = html;
        }
        
        // Toggle rules visibility
        function toggleRules(rulesId) {
            const rulesEl = document.getElementById(rulesId);
            if (rulesEl) {
                rulesEl.classList.toggle('show');
                const toggleBtn = event.target;
                toggleBtn.textContent = rulesEl.classList.contains('show') ? 'Hide rules ‚ñ≤' : 'View rules ‚ñº';
            }
        }
        
        function renderInsights(data) {
            const insights = analyzeInsights(data);
            let html = '<div class="insights-container">';
            
            // Overall status
            html += `<div class="status-badge ${insights.overallStatus}">${insights.statusText}</div>`;
            
            // Rich Results eligibility
            if (insights.richResults.length > 0) {
                html += '<div class="insight-section">';
                html += '<div class="insight-header">üéØ Google Rich Results Eligibility</div>';
                html += '<div class="rich-results">';
                insights.richResults.forEach(result => {
                    html += `<div class="rich-result ${result.status}">${result.icon} ${result.name}</div>`;
                });
                html += '</div></div>';
            }
            
            // Strengths - ALWAYS SHOW FIRST to highlight what's working
            if (insights.strengths.length > 0) {
                html += '<div class="insight-section">';
                html += '<div class="insight-header">‚úÖ What\'s Working Well</div>';
                html += '<ul class="strengths-list">';
                insights.strengths.forEach(strength => {
                    html += `<li>‚úì ${strength}</li>`;
                });
                html += '</ul></div>';
            }
            
            // Critical issues
            if (insights.critical.length > 0) {
                html += '<div class="insight-section">';
                html += '<div class="insight-header">üî¥ Critical Issues</div>';
                insights.critical.forEach(issue => {
                    html += `<div class="insight-card critical">`;
                    html += `<div class="insight-title">${issue.title}</div>`;
                    html += `<div class="insight-why"><strong>Why:</strong> ${issue.why}</div>`;
                    html += `<div class="insight-fix"><strong>How to fix:</strong> ${issue.fix}</div>`;
                    if (issue.impact) html += `<div class="insight-impact">Impact: ${issue.impact}</div>`;
                    if (issue.reference) html += `<div class="insight-reference">üìö Reference: <a href="${issue.reference}" target="_blank">${issue.referenceText}</a></div>`;
                    html += '</div>';
                });
                html += '</div>';
            }
            
            // High priority
            if (insights.high.length > 0) {
                html += '<div class="insight-section">';
                html += '<div class="insight-header">üü° High Priority</div>';
                insights.high.forEach(issue => {
                    html += `<div class="insight-card high">`;
                    html += `<div class="insight-title">${issue.title}</div>`;
                    html += `<div class="insight-why"><strong>Why:</strong> ${issue.why}</div>`;
                    html += `<div class="insight-fix"><strong>How to fix:</strong> ${issue.fix}</div>`;
                    if (issue.impact) html += `<div class="insight-impact">Impact: ${issue.impact}</div>`;
                    if (issue.reference) html += `<div class="insight-reference">üìö Reference: <a href="${issue.reference}" target="_blank">${issue.referenceText}</a></div>`;
                    html += '</div>';
                });
                html += '</div>';
            }
            
            // Recommended
            if (insights.recommended.length > 0) {
                html += '<div class="insight-section">';
                html += '<div class="insight-header">üîµ Recommended Improvements</div>';
                insights.recommended.forEach(issue => {
                    html += `<div class="insight-card recommended">`;
                    html += `<div class="insight-title">${issue.title}</div>`;
                    html += `<div class="insight-why"><strong>Why:</strong> ${issue.why}</div>`;
                    html += `<div class="insight-fix"><strong>How to fix:</strong> ${issue.fix}</div>`;
                    if (issue.impact) html += `<div class="insight-impact">Impact: ${issue.impact}</div>`;
                    if (issue.reference) html += `<div class="insight-reference">üìö Reference: <a href="${issue.reference}" target="_blank">${issue.referenceText}</a></div>`;
                    html += '</div>';
                });
                html += '</div>';
            }
            
            html += '</div>';
            document.getElementById('insightsOutput').innerHTML = html;
            
            // Add event delegation for AI Readiness tab links
            document.getElementById('insightsOutput').addEventListener('click', (e) => {
                if (e.target.classList.contains('switch-to-ai-tab')) {
                    e.preventDefault();
                    document.querySelector('[data-tab="ai-readiness"]').click();
                }
            });
        }
        
        function analyzeInsights(data) {
            const insights = {
                critical: [],
                high: [],
                recommended: [],
                optional: [],
                strengths: [],
                richResults: [],
                overallStatus: 'status-good',
                statusText: 'Good'
            };
            
            // DEBUG: Log data structure
            console.log('Analyzing data:', {
                hasGraph: !!data.graph,
                graphNodes: data.graph?.nodes?.length || 0,
                jsonldCount: data.jsonld?.length || 0,
                jsonldSample: data.jsonld?.[0]
            });
            
            // Extract entity types with null checks - check BOTH graph and jsonld
            const entityTypesFromGraph = data.graph && data.graph.nodes 
                ? [...new Set(data.graph.nodes.flatMap(n => n.types || []))]
                : [];
            
            const entityTypesFromJsonLd = data.jsonld 
                ? [...new Set(data.jsonld.flatMap(item => {
                    const type = item['@type'];
                    return Array.isArray(type) ? type : (type ? [type] : []);
                }))]
                : [];
            
            const entityTypes = [...new Set([...entityTypesFromGraph, ...entityTypesFromJsonLd])];
            
            console.log('Entity types found:', entityTypes);
            
            const hasProduct = entityTypes.some(t => t && t.includes('Product'));
            const hasVehicle = entityTypes.some(t => t && (t.includes('Vehicle') || t.includes('Car')));
            const hasProductOrVehicle = hasProduct || hasVehicle; // Treat vehicles as products for e-commerce checks
            const hasOrganization = entityTypes.some(t => t && t.includes('Organization'));
            const hasBreadcrumb = entityTypes.some(t => t && t.includes('BreadcrumbList'));
            const hasOffer = entityTypes.some(t => t && t.includes('Offer'));
            const hasReview = entityTypes.some(t => t && (t.includes('Review') || t.includes('AggregateRating')));
            
            console.log('Type detection:', { hasProduct, hasVehicle, hasProductOrVehicle, hasOrganization, hasBreadcrumb, hasOffer, hasReview });
            
            // Check if any JSON-LD exists
            if (!data.jsonld || data.jsonld.length === 0) {
                insights.critical.push({
                    title: 'No Structured Data Found',
                    why: 'Search engines cannot understand your content without structured data, severely limiting visibility in search results.',
                    fix: 'Add JSON-LD structured data to your page using Schema.org vocabulary. Start with basic Organization or WebPage type.',
                    impact: 'Cannot appear in Google Rich Results',
                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/intro-structured-data',
                    referenceText: 'Google Structured Data Guidelines'
                });
                insights.overallStatus = 'status-critical';
                insights.statusText = 'Critical Issues Found';
                return insights;
            }
            
            // Helper function to find all items of a type (handles nested @graph)
            function findItemsByType(jsonld, type) {
                const items = [];
                
                function searchItem(item) {
                    if (!item) return;
                    
                    // Check if this item matches the type
                    const itemType = item['@type'];
                    if (itemType) {
                        const types = Array.isArray(itemType) ? itemType : [itemType];
                        if (types.some(t => String(t).includes(type))) {
                            items.push(item);
                        }
                    }
                    
                    // Search in @graph array
                    if (item['@graph'] && Array.isArray(item['@graph'])) {
                        item['@graph'].forEach(searchItem);
                    }
                    
                    // Search in nested objects
                    Object.values(item).forEach(value => {
                        if (value && typeof value === 'object' && !Array.isArray(value) && value !== item) {
                            searchItem(value);
                        }
                    });
                }
                
                jsonld.forEach(searchItem);
                return items;
            }
            
            // Product-specific checks (includes Vehicle/Car as product-like items)
            if (hasProductOrVehicle) {
                insights.richResults.push({ name: 'Product', status: 'eligible', icon: '‚úÖ' });
                
                // Find both Product and Vehicle types
                const products = [
                    ...findItemsByType(data.jsonld, 'Product'),
                    ...findItemsByType(data.jsonld, 'Vehicle'),
                    ...findItemsByType(data.jsonld, 'Car')
                ];
                
                console.log('Products found:', products.length, products);
                
                if (products.length === 0) {
                    // Fallback: products might be in @graph structure
                    console.warn('No products found via findItemsByType, checking graph structure...');
                }
                
                products.forEach(product => {
                    // Check required fields for Product Rich Results
                    if (!product.name) {
                        insights.critical.push({
                            title: 'Product Missing "name" Property',
                            why: 'Google requires a product name to show Product Rich Results. Without it, your product won\'t appear in enhanced search listings.',
                            fix: 'Add a "name" property to your Product schema with the product title.',
                            impact: 'Product Rich Results will not appear',
                            reference: 'https://developers.google.com/search/docs/appearance/structured-data/product',
                            referenceText: 'Google Product Rich Results'
                        });
                    } else {
                        insights.strengths.push(`Product name present: "${product.name}"`);
                    }
                    
                    if (!product.image && !product.images) {
                        insights.high.push({
                            title: 'Product Missing "image" Property',
                            why: 'Product images significantly improve click-through rates in search results. Google strongly recommends including images for Product Rich Results.',
                            fix: 'Add an "image" property with a high-quality product image URL (minimum 800px width recommended).',
                            impact: 'Lower visibility and CTR in search results',
                            reference: 'https://developers.google.com/search/docs/appearance/structured-data/product',
                            referenceText: 'Google Product Image Guidelines'
                        });
                    } else {
                        const imageCount = Array.isArray(product.image) ? product.image.length : 1;
                        insights.strengths.push(`Product image(s): ${imageCount} image${imageCount !== 1 ? 's' : ''}`);
                    }
                    
                    // Check for price/offer - E-COMMERCE EXPANDED
                    const offers = product.offers || product.offer;
                    const offerArray = Array.isArray(offers) ? offers : (offers ? [offers] : []);
                    
                    if (!hasOffer && offerArray.length === 0) {
                        insights.high.push({
                            title: 'Product Missing Pricing Information',
                            why: 'Price is a required field for Product Rich Results. Without it, Google cannot display your product in enhanced search listings with pricing.',
                            fix: 'Add an "offers" property with Offer type including "price", "priceCurrency", and "availability".',
                            impact: 'Product Rich Results will not show pricing',
                            reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#offer',
                            referenceText: 'Google Product Offer Requirements'
                        });
                    } else {
                        const priceOffer = offerArray.find(o => o.priceCurrency);
                        const currency = priceOffer?.priceCurrency || '';
                        const currencyInfo = currency ? ` in ${currency}` : '';
                        insights.strengths.push(`Pricing information present${currencyInfo}`);
                        
                        // E-COMMERCE: Deep offer analysis
                        offerArray.forEach(offer => {
                            // Check price currency
                            if (!offer.priceCurrency) {
                                insights.high.push({
                                    title: 'Offer Missing "priceCurrency"',
                                    why: 'Google requires currency information to display prices correctly in search results. Missing currency can cause prices to not display.',
                                    fix: 'Add "priceCurrency" property with ISO 4217 currency code (e.g., "USD", "EUR", "GBP").',
                                    impact: 'Price may not display in Rich Results',
                                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#offer',
                                    referenceText: 'Google Offer Requirements'
                                });
                            }
                            
                            // Check availability
                            if (!offer.availability) {
                                insights.high.push({
                                    title: 'Offer Missing "availability" Status',
                                    why: 'Availability information tells customers if the product is in stock, which is crucial for e-commerce conversions and can appear in search results.',
                                    fix: 'Add "availability" property with Schema.org ItemAvailability value (e.g., "https://schema.org/InStock", "https://schema.org/OutOfStock", "https://schema.org/PreOrder").',
                                    impact: 'Users cannot see stock status in search results',
                                    reference: 'https://schema.org/Offer',
                                    referenceText: 'Schema.org Offer Availability'
                                });
                            } else {
                                const availabilityStr = String(offer.availability).toLowerCase();
                                if (availabilityStr.includes('instock')) {
                                    const availType = availabilityStr.includes('onlineonly') ? ' (Online Only)' : 
                                                     availabilityStr.includes('instoreonly') ? ' (In Store Only)' : '';
                                    insights.strengths.push(`Product availability: In Stock${availType}`);
                                } else if (availabilityStr.includes('outofstock')) {
                                    insights.recommended.push({
                                        title: 'Product Marked Out of Stock',
                                        why: 'Out of stock products have lower visibility and conversion rates. Consider removing from search results or showing estimated restock date.',
                                        fix: 'Update availability to "InStock" when available, or consider adding "availabilityStarts" property for pre-orders.',
                                        impact: 'Lower conversion rates for out-of-stock items',
                                        reference: 'https://schema.org/ItemAvailability',
                                        referenceText: 'Schema.org Availability Options'
                                    });
                                }
                            }
                            
                            // E-COMMERCE: Check for shipping information
                            if (!offer.shippingDetails && !offer.shippingRate) {
                                insights.recommended.push({
                                    title: 'Consider Adding Shipping Information',
                                    why: 'Shipping costs are a major factor in purchase decisions. Displaying shipping information upfront can improve conversion rates and qualify for Google Merchant Center.',
                                    fix: 'Add "shippingDetails" property with OfferShippingDetails type including shipping destination, rate, and delivery time.',
                                    impact: 'Better customer experience, Google Merchant Center eligibility',
                                    reference: 'https://schema.org/OfferShippingDetails',
                                    referenceText: 'Schema.org Shipping Details'
                                });
                            } else {
                                const shippingDetails = [];
                                if (offer.deliveryTime) shippingDetails.push('delivery time specified');
                                if (offer.shippingRate) shippingDetails.push('shipping rate');
                                const detailStr = shippingDetails.length > 0 ? ` (${shippingDetails.join(', ')})` : '';
                                insights.strengths.push(`Shipping information included${detailStr}`);
                            }
                            
                            // E-COMMERCE: Check for return policy
                            if (!offer.hasMerchantReturnPolicy && !product.hasMerchantReturnPolicy) {
                                insights.recommended.push({
                                    title: 'Add Return Policy Information',
                                    why: 'Clear return policies increase customer confidence and conversion rates. Google can display return policy in product rich results.',
                                    fix: 'Add "hasMerchantReturnPolicy" property with MerchantReturnPolicy type including return window and fees.',
                                    impact: 'Increased customer trust and higher conversion rates',
                                    reference: 'https://schema.org/MerchantReturnPolicy',
                                    referenceText: 'Schema.org Return Policy'
                                });
                            } else {
                                const policy = offer.hasMerchantReturnPolicy || product.hasMerchantReturnPolicy;
                                let policyInfo = '';
                                if (policy && policy.returnPolicyCategory) {
                                    policyInfo = ` (${policy.returnPolicyCategory})`;
                                } else if (policy && policy.merchantReturnDays) {
                                    policyInfo = ` (${policy.merchantReturnDays} days)`;
                                }
                                insights.strengths.push(`Return policy information included${policyInfo}`);
                            }
                            
                            // E-COMMERCE: Check for price validity dates
                            if (offer.priceValidUntil) {
                                insights.strengths.push('Price validity date specified (good for sales/promotions)');
                            } else if (offer.price) {
                                insights.recommended.push({
                                    title: 'Consider Adding Price Validity Date',
                                    why: 'For promotional pricing or time-limited offers, a validity date helps Google show accurate pricing and creates urgency.',
                                    fix: 'Add "priceValidUntil" property with ISO 8601 date (e.g., "2025-12-31").',
                                    impact: 'Better handling of promotional pricing',
                                    reference: 'https://schema.org/Offer',
                                    referenceText: 'Schema.org Offer Properties'
                                });
                            }
                            
                            // E-COMMERCE: Check for seller/merchant info
                            if (!offer.seller && !offer.offeredBy) {
                                insights.recommended.push({
                                    title: 'Consider Adding Seller Information',
                                    why: 'For marketplace sites, seller information helps customers identify who they\'re buying from and can improve trust.',
                                    fix: 'Add "seller" or "offeredBy" property with Organization type.',
                                    impact: 'Improved transparency for marketplace products',
                                    reference: 'https://schema.org/seller',
                                    referenceText: 'Schema.org Seller Property'
                                });
                            }
                        });
                    }
                    
                    // E-COMMERCE: Check for product variants
                    if (product['@type'] === 'ProductGroup' || product.hasVariant || product.variesBy) {
                        const isProductGroup = product['@type'] === 'ProductGroup' || (Array.isArray(product['@type']) && product['@type'].includes('ProductGroup'));
                        
                        if (product.hasVariant) {
                            const variants = Array.isArray(product.hasVariant) ? product.hasVariant : [product.hasVariant];
                            const variantCount = variants.length;
                            insights.strengths.push(`Product has ${variantCount} variant${variantCount > 1 ? 's' : ''} (colors, sizes, etc.)`);
                            
                            // PRIORITY 1: Deep variant analysis
                            let variantsWithoutIdentifiers = 0;
                            let variantsWithoutOffers = 0;
                            let variantsWithoutImages = 0;
                            const variantIdentifierIssues = [];
                            const variantOfferIssues = [];
                            const variantImageIssues = [];
                            
                            variants.forEach((variant, index) => {
                                const variantName = variant.name || `Variant ${index + 1}`;
                                
                                // Check 1: Each variant MUST have unique identifier
                                const hasIdentifier = variant.sku || variant.gtin || variant.mpn || 
                                                     variant.gtin13 || variant.gtin12 || variant.gtin14 || variant.gtin8;
                                if (!hasIdentifier) {
                                    variantsWithoutIdentifiers++;
                                    variantIdentifierIssues.push(variantName);
                                }
                                
                                // Check 2: Each variant MUST have offer/pricing
                                const variantOffers = variant.offers || variant.offer;
                                const hasOffer = variantOffers && (Array.isArray(variantOffers) ? variantOffers.length > 0 : true);
                                if (!hasOffer) {
                                    variantsWithoutOffers++;
                                    variantOfferIssues.push(variantName);
                                }
                                
                                // Check 3: Each variant should have image
                                if (!variant.image && !variant.images) {
                                    variantsWithoutImages++;
                                    variantImageIssues.push(variantName);
                                }
                            });
                            
                            // Report variant identifier issues
                            if (variantsWithoutIdentifiers > 0) {
                                insights.critical.push({
                                    title: `${variantsWithoutIdentifiers} Variant${variantsWithoutIdentifiers > 1 ? 's' : ''} Missing Unique Identifier`,
                                    why: 'Each product variant MUST have a unique identifier (SKU, GTIN, or MPN) to track inventory, prevent duplicate orders, and enable Google Shopping.',
                                    fix: `Add unique "sku", "gtin", or "mpn" to these variants: ${variantIdentifierIssues.slice(0, 3).join(', ')}${variantIdentifierIssues.length > 3 ? ` and ${variantIdentifierIssues.length - 3} more` : ''}`,
                                    impact: 'Cannot track which variant was purchased, Google Shopping blocked',
                                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#product',
                                    referenceText: 'Google Product Identifier Requirements'
                                });
                            } else {
                                insights.strengths.push('All variants have unique identifiers');
                            }
                            
                            // Report variant offer issues
                            if (variantsWithoutOffers > 0) {
                                insights.critical.push({
                                    title: `${variantsWithoutOffers} Variant${variantsWithoutOffers > 1 ? 's' : ''} Missing Pricing Information`,
                                    why: 'Each variant must have its own "offers" property with price, currency, and availability. Without it, customers cannot purchase that specific variant.',
                                    fix: `Add "offers" with Offer type to these variants: ${variantOfferIssues.slice(0, 3).join(', ')}${variantOfferIssues.length > 3 ? ` and ${variantOfferIssues.length - 3} more` : ''}`,
                                    impact: 'Variants cannot be purchased, no pricing shown in search results',
                                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#offer',
                                    referenceText: 'Google Product Offer Requirements'
                                });
                            } else {
                                insights.strengths.push('All variants have pricing information');
                            }
                            
                            // Report variant image issues
                            if (variantsWithoutImages > 0) {
                                insights.high.push({
                                    title: `${variantsWithoutImages} Variant${variantsWithoutImages > 1 ? 's' : ''} Missing Images`,
                                    why: 'Each variant should have its own image showing the specific color, style, or configuration. This dramatically improves conversion rates and user experience.',
                                    fix: `Add "image" property to these variants: ${variantImageIssues.slice(0, 3).join(', ')}${variantImageIssues.length > 3 ? ` and ${variantImageIssues.length - 3} more` : ''}`,
                                    impact: 'Lower conversion rates, poor user experience, harder to distinguish variants',
                                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#product',
                                    referenceText: 'Google Product Image Guidelines'
                                });
                            } else {
                                insights.strengths.push('All variants have images');
                            }
                            
                            // Check if ProductGroup itself has an offer (it shouldn't)
                            if (isProductGroup) {
                                const groupOffers = product.offers || product.offer;
                                if (groupOffers) {
                                    insights.high.push({
                                        title: 'ProductGroup Has Direct Offer (Should Be On Variants)',
                                        why: 'ProductGroups should NOT have their own offers. Only the individual variant Products should have offers. This creates confusion about which variant is being purchased.',
                                        fix: 'Remove "offers" from the ProductGroup and ensure each variant has its own "offers" property.',
                                        impact: 'Unclear which variant customer is purchasing, potential order errors',
                                        reference: 'https://schema.org/ProductGroup',
                                        referenceText: 'Schema.org ProductGroup Specification'
                                    });
                                } else {
                                    insights.strengths.push('ProductGroup correctly delegates offers to variants');
                                }
                            }
                        }
                        
                        if (product.variesBy) {
                            const variesByProps = Array.isArray(product.variesBy) ? product.variesBy : [product.variesBy];
                            insights.strengths.push(`Variant properties specified: ${variesByProps.join(', ')}`);
                            
                            // Validate that variesBy matches reality
                            if (product.hasVariant) {
                                const variants = Array.isArray(product.hasVariant) ? product.hasVariant : [product.hasVariant];
                                const missingProps = variesByProps.filter(prop => {
                                    // Check if at least one variant has this property
                                    return !variants.some(v => v[prop]);
                                });
                                
                                if (missingProps.length > 0) {
                                    insights.high.push({
                                        title: `"variesBy" Claims Properties That Variants Don't Have`,
                                        why: `The variesBy property lists "${missingProps.join(', ')}" but none of the variants actually have these properties. This misleads search engines about how variants differ.`,
                                        fix: `Either add the missing properties (${missingProps.join(', ')}) to variants, or remove them from variesBy array.`,
                                        impact: 'Inaccurate variant filtering, confused search engines',
                                        reference: 'https://schema.org/variesBy',
                                        referenceText: 'Schema.org variesBy Property'
                                    });
                                }
                            }
                        } else if (product.hasVariant) {
                            insights.recommended.push({
                                title: 'Add "variesBy" Property to ProductGroup',
                                why: 'The variesBy property helps search engines understand how your product variants differ (e.g., color, size), improving product discovery.',
                                fix: 'Add "variesBy" property with array of property names like ["color", "size"].',
                                impact: 'Better variant filtering in search results',
                                reference: 'https://schema.org/variesBy',
                                referenceText: 'Schema.org variesBy Property'
                            });
                        }
                    } else {
                        // NO VARIANTS DETECTED - Suggest if they should exist
                        // Check if product name/description suggests multiple options
                        const name = (product.name || '').toLowerCase();
                        const desc = (product.description || '').toLowerCase();
                        const text = name + ' ' + desc;
                        
                        // Indicators that variants might exist
                        const colorIndicators = ['color', 'colour', 'black', 'white', 'blue', 'red', 'green', 'yellow', 'available in', 'choice of'];
                        const sizeIndicators = ['size', 'small', 'medium', 'large', 'xl', 'xxl', 's/m/l'];
                        const configIndicators = ['configuration', 'model', 'version', 'edition', 'trim', 'package', 'option'];
                        
                        // Special indicators for vehicles
                        const vehicleConfigIndicators = ['interior', 'exterior', 'engine', 'wheels', 'seats', 'paint', 'drivetrain', 'battery'];
                        
                        const hasColorHints = colorIndicators.some(indicator => text.includes(indicator));
                        const hasSizeHints = sizeIndicators.some(indicator => text.includes(indicator));
                        const hasConfigHints = configIndicators.some(indicator => text.includes(indicator));
                        const hasVehicleConfigHints = vehicleConfigIndicators.some(indicator => text.includes(indicator));
                        
                        const hasAnyVariantHints = hasColorHints || hasSizeHints || hasConfigHints || hasVehicleConfigHints;
                        
                        if (hasAnyVariantHints) {
                            const hints = [];
                            if (hasColorHints) hints.push('colors');
                            if (hasSizeHints) hints.push('sizes');
                            if (hasConfigHints) hints.push('configurations');
                            if (hasVehicleConfigHints) hints.push('options');
                            
                            insights.recommended.push({
                                title: `Consider Using Product Variants for "${product.name || 'this product'}"`,
                                why: `This product mentions ${hints.join(', ')}, suggesting multiple options are available. Using ProductGroup with variants helps customers find the exact option they want and improves search visibility for each variant.`,
                                fix: 'If this product comes in multiple colors/sizes/configurations, use ProductGroup schema with "hasVariant" property linking to individual Product variants. Each variant should have unique SKU, price, and image.',
                                impact: 'Better product discovery, clearer customer choice, improved conversion rates',
                                reference: 'https://schema.org/ProductGroup',
                                referenceText: 'Schema.org ProductGroup with Variants'
                            });
                        } else {
                            // No obvious hints, but for certain product types (vehicles), variants are almost always relevant
                            const isVehicle = hasVehicle && (product['@type'] === 'Vehicle' || product['@type'] === 'Car' || 
                                            (Array.isArray(product['@type']) && (product['@type'].includes('Vehicle') || product['@type'].includes('Car'))));
                            
                            if (isVehicle) {
                                // Vehicles almost always have multiple configurations
                                insights.recommended.push({
                                    title: `Does "${product.name || 'this product'}" Have Multiple Configurations?`,
                                    why: 'Most products come in multiple configurations, colors, and option packages. Using ProductGroup with variants allows customers to compare options and helps search engines understand all available configurations.',
                                    fix: 'Use ProductGroup with "hasVariant" array linking to each configuration as separate Product items. Include variesBy property like ["color", "trim", "option"] to specify what differs.',
                                    impact: 'Better configuration discovery, clearer pricing per option, improved customer experience',
                                    reference: 'https://schema.org/ProductGroup',
                                    referenceText: 'Schema.org ProductGroup Documentation'
                                });
                            } else {
                                // Regular products without obvious variant hints
                                insights.strengths.push('Single product variant (no color/size options)');
                            }
                        }
                    }
                    
                    // E-COMMERCE: Check for SKU/GTIN/MPN
                    if (!product.sku && !product.gtin && !product.mpn && !product.gtin13 && !product.gtin12 && !product.gtin14 && !product.gtin8) {
                        insights.high.push({
                            title: 'Product Missing Identifier (SKU/GTIN/MPN)',
                            why: 'Product identifiers (SKU, GTIN, MPN) are required for Google Merchant Center and help search engines match your products correctly. Missing identifiers can prevent products from appearing in Google Shopping.',
                            fix: 'Add at least one identifier: "sku" (your internal ID), "gtin" (barcode), or "mpn" (manufacturer part number).',
                            impact: 'Google Shopping eligibility, better product matching',
                            reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#product',
                            referenceText: 'Google Product Identifier Requirements'
                        });
                    } else {
                        const identifiers = [];
                        if (product.sku) identifiers.push('SKU');
                        if (product.gtin || product.gtin13 || product.gtin12 || product.gtin14 || product.gtin8) identifiers.push('GTIN');
                        if (product.mpn) identifiers.push('MPN');
                        insights.strengths.push(`Product identifiers present: ${identifiers.join(', ')}`);
                    }
                    
                    // E-COMMERCE: Check for condition (new/used/refurbished)
                    if (product.itemCondition) {
                        const condition = String(product.itemCondition).toLowerCase();
                        if (condition.includes('new')) {
                            insights.strengths.push('Product condition: New');
                        } else {
                            insights.strengths.push(`Product condition specified: ${product.itemCondition}`);
                        }
                    } else {
                        insights.recommended.push({
                            title: 'Add Product Condition',
                            why: 'Product condition (New, Used, Refurbished) is important for customer expectations and Google Shopping listings.',
                            fix: 'Add "itemCondition" property with value like "https://schema.org/NewCondition".',
                            impact: 'Clearer customer expectations, Google Shopping compatibility',
                            reference: 'https://schema.org/itemCondition',
                            referenceText: 'Schema.org Item Condition'
                        });
                    }
                    
                    // Check for description
                    if (!product.description) {
                        insights.recommended.push({
                            title: 'Product Missing "description" Property',
                            why: 'Descriptions help search engines understand your product better and can appear in search snippets.',
                            fix: 'Add a "description" property with a clear, concise product description (50-200 characters recommended).',
                            impact: 'Better search result snippets and improved relevance',
                            reference: 'https://schema.org/Product',
                            referenceText: 'Schema.org Product Specification'
                        });
                    } else {
                        const descLength = product.description.length;
                        const lengthNote = descLength < 100 ? ' (short - consider expanding)' : 
                                         descLength > 500 ? ' (detailed)' : 
                                         ' (good length)';
                        insights.strengths.push(`Product description present${lengthNote}`);
                    }
                    
                    // Check for brand
                    if (!product.brand) {
                        insights.recommended.push({
                            title: 'Product Missing "brand" Property',
                            why: 'Brand information helps users identify products and can appear in rich results, improving trust and click-through rates.',
                            fix: 'Add a "brand" property with Organization or Brand type including the manufacturer name.',
                            impact: 'Enhanced user trust and better product identification',
                            reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#product',
                            referenceText: 'Google Product Brand Guidelines'
                        });
                    } else {
                        insights.strengths.push(`Brand present: ${product.brand.name || 'specified'}`);
                    }
                    
                    // E-COMMERCE: Check for material/color/size attributes
                    const hasAttributes = product.material || product.color || product.size || product.width || product.height || product.depth || product.weight;
                    if (hasAttributes) {
                        const attributes = [];
                        if (product.material) attributes.push('material');
                        if (product.color) attributes.push('color');
                        if (product.size) attributes.push('size');
                        if (product.weight) attributes.push('weight');
                        insights.strengths.push(`Product attributes specified: ${attributes.join(', ')}`);
                    } else {
                        insights.recommended.push({
                            title: 'Consider Adding Product Attributes',
                            why: 'Detailed product attributes (material, color, size, weight) help customers make informed decisions and improve product filtering in search.',
                            fix: 'Add relevant properties like "material", "color", "size", "weight" to your Product schema.',
                            impact: 'Better product filtering and customer decisions',
                            reference: 'https://schema.org/Product',
                            referenceText: 'Schema.org Product Properties'
                        });
                    }
                    
                    // E-COMMERCE: Check for warranty information
                    if (product.warranty) {
                        const warranty = product.warranty;
                        let warrantyInfo = '';
                        if (warranty.durationOfWarranty) {
                            warrantyInfo = ` (${warranty.durationOfWarranty})`;
                        } else if (warranty.warrantyDuration) {
                            warrantyInfo = ` (${warranty.warrantyDuration})`;
                        }
                        insights.strengths.push(`Warranty information included${warrantyInfo}`);
                    }
                });
                
                // E-COMMERCE: Overall product setup check (include Product, Vehicle, Car)
                const allProducts = [
                    ...findItemsByType(data.jsonld, 'Product'),
                    ...findItemsByType(data.jsonld, 'Vehicle'),
                    ...findItemsByType(data.jsonld, 'Car')
                ];
                
                // Check if products have offers - for ProductGroups, check variants instead
                const productsWithOffers = allProducts.filter(p => {
                    // If it's a ProductGroup with variants, check if variants have offers
                    const isProductGroup = p['@type'] === 'ProductGroup' || 
                                          (Array.isArray(p['@type']) && p['@type'].includes('ProductGroup'));
                    
                    if (isProductGroup && p.hasVariant) {
                        const variants = Array.isArray(p.hasVariant) ? p.hasVariant : [p.hasVariant];
                        // ProductGroup is considered to have offers if ANY variant has offers
                        return variants.some(v => {
                            const variantOffers = v.offers || v.offer;
                            return variantOffers && (Array.isArray(variantOffers) ? variantOffers.length > 0 : true);
                        });
                    }
                    
                    // For regular products, check directly
                    const offers = p.offers || p.offer;
                    return offers && (Array.isArray(offers) ? offers.length > 0 : true);
                });
                
                if (allProducts.length > 0 && productsWithOffers.length === 0) {
                    insights.critical.push({
                        title: '‚ö†Ô∏è Products Found But Not E-Commerce Ready',
                        why: 'You have product schema on your page, but no pricing/offer information. This suggests the page is informational rather than e-commerce. Products without offers cannot appear in Google Shopping or show pricing in search results.',
                        fix: 'If this is an e-commerce site: Add "offers" property with price, currency, and availability to each product. If this is NOT for selling: This is fine for informational/brochure sites, but you\'re missing e-commerce opportunities.',
                        impact: 'Cannot appear in Google Shopping, missing revenue opportunities',
                        reference: 'https://developers.google.com/search/docs/appearance/structured-data/product#product',
                        referenceText: 'Google Product Requirements'
                    });
                }
                
                // Check if products lack identifiers (common on manufacturer sites)
                // For ProductGroups, check variants; for regular products, check directly
                const productsWithIdentifiers = allProducts.filter(p => {
                    // If it's a ProductGroup with variants, check if variants have identifiers
                    const isProductGroup = p['@type'] === 'ProductGroup' || 
                                          (Array.isArray(p['@type']) && p['@type'].includes('ProductGroup'));
                    
                    if (isProductGroup && p.hasVariant) {
                        const variants = Array.isArray(p.hasVariant) ? p.hasVariant : [p.hasVariant];
                        // ProductGroup is considered to have identifiers if ANY variant has identifiers
                        return variants.some(v => 
                            v.sku || v.gtin || v.mpn || v.gtin13 || v.gtin12 || v.gtin14 || v.gtin8
                        );
                    }
                    
                    // For regular products, check directly
                    return p.sku || p.gtin || p.mpn || p.gtin13 || p.gtin12 || p.gtin14 || p.gtin8;
                });
                
                if (allProducts.length > 0 && productsWithIdentifiers.length === 0) {
                    insights.high.push({
                        title: 'No Product Identifiers Found on ANY Product',
                        why: 'None of your products have SKU, GTIN, or MPN identifiers. This completely blocks Google Shopping eligibility and makes product matching impossible.',
                        fix: 'Add unique identifiers to each product variant. Use "sku" for internal IDs, "gtin" for barcodes (EAN/UPC), or "mpn" for manufacturer part numbers.',
                        impact: 'Zero Google Shopping visibility',
                        reference: 'https://support.google.com/merchants/answer/6324461',
                        referenceText: 'Google Merchant Center Product ID Requirements'
                    });
                }
            }
            
            // Review/Rating checks
            if (hasReview) {
                insights.strengths.push('Review/Rating data present (enhances credibility)');
            } else if (hasProductOrVehicle) {
                insights.recommended.push({
                    title: 'Consider Adding Product Reviews',
                    why: 'Product reviews with ratings display star ratings in search results, significantly increasing click-through rates (studies show 20-30% improvement).',
                    fix: 'Add "aggregateRating" or "review" properties with Review or AggregateRating types to your Product schema.',
                    impact: 'Star ratings in search results, higher CTR',
                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/review-snippet',
                    referenceText: 'Google Review Rich Results'
                });
            }
            
            // Organization checks
            if (hasOrganization) {
                const orgs = findItemsByType(data.jsonld, 'Organization');
                if (orgs.length > 0) {
                    const org = orgs[0];
                    const orgDetails = [];
                    if (org.name) orgDetails.push(`name: "${org.name}"`);
                    if (org.logo) orgDetails.push('logo');
                    if (org.url) orgDetails.push('website');
                    if (org.sameAs) orgDetails.push(`${Array.isArray(org.sameAs) ? org.sameAs.length : 1} social profile(s)`);
                    const detailStr = orgDetails.length > 0 ? ` (${orgDetails.join(', ')})` : '';
                    insights.strengths.push(`Organization data present${detailStr}`);
                }
            } else {
                insights.recommended.push({
                    title: 'Add Organization Structured Data',
                    why: 'Organization schema helps Google display your business information in knowledge panels and enhances brand visibility.',
                    fix: 'Add Organization schema with "name", "url", "logo", and optionally "sameAs" for social media profiles.',
                    impact: 'Knowledge Graph eligibility, enhanced brand presence',
                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/logo',
                    referenceText: 'Google Organization Guidelines'
                });
            }
            
            // Breadcrumb checks
            if (hasBreadcrumb) {
                insights.richResults.push({ name: 'Breadcrumbs', status: 'eligible', icon: '‚úÖ' });
                const breadcrumbs = findItemsByType(data.jsonld, 'BreadcrumbList');
                if (breadcrumbs.length > 0) {
                    const bc = breadcrumbs[0];
                    const itemCount = bc.itemListElement ? (Array.isArray(bc.itemListElement) ? bc.itemListElement.length : 1) : 0;
                    insights.strengths.push(`Breadcrumb navigation: ${itemCount} level${itemCount !== 1 ? 's' : ''} of hierarchy`);
                } else {
                    insights.strengths.push('Breadcrumb navigation structured data present');
                }
            } else {
                insights.recommended.push({
                    title: 'Add Breadcrumb Structured Data',
                    why: 'Breadcrumbs appear in search results and help users understand your site structure, improving navigation and SEO.',
                    fix: 'Add BreadcrumbList schema showing the page hierarchy from homepage to current page.',
                    impact: 'Enhanced search result appearance with breadcrumb trail',
                    reference: 'https://developers.google.com/search/docs/appearance/structured-data/breadcrumb',
                    referenceText: 'Google Breadcrumb Guidelines'
                });
            }
            
            // Check for more specific schema types (Vehicle, Car, etc.)
            if (hasVehicle) {
                insights.strengths.push('Using Vehicle/Car schema (more specific than generic Product)');
            } else if (hasProduct) {
                // Check if product name/description suggests it should be a Vehicle
                const allProducts = findItemsByType(data.jsonld, 'Product');
                const seemsLikeVehicle = allProducts.some(p => {
                    const name = (p.name || '').toLowerCase();
                    const desc = (p.description || '').toLowerCase();
                    const text = name + ' ' + desc;
                    return text.includes('car') || text.includes('vehicle') || text.includes('auto') || 
                           text.includes('suv') || text.includes('sedan') || text.includes('truck') ||
                           text.includes('electric vehicle') || text.includes('hybrid');
                });
                
                if (seemsLikeVehicle) {
                    insights.recommended.push({
                        title: 'Consider Using More Specific Product Schema',
                        why: 'Your products appear to be vehicles. Using the more specific Vehicle/Car schema type (instead of generic Product) provides better semantic understanding and may unlock additional rich results.',
                        fix: 'Change @type from "Product" to "Car" or "Vehicle" and include specific properties like "vehicleModelDate", "fuelType", "driveWheelConfiguration".',
                        impact: 'Better semantic understanding, potential for specialized rich results',
                        reference: 'https://schema.org/Car',
                        referenceText: 'Schema.org Vehicle Types'
                    });
                }
            }
            
            // AI Readiness Integration
            if (data.aiReadiness) {
                const ar = data.aiReadiness;
                
                // Check .well-known files (it's an object, not an array)
                if (ar.wellKnown) {
                    const wk = ar.wellKnown;
                    
                    // Map technical field names to user-friendly descriptions
                    const fileDescriptions = {
                        'aiPluginJson': { name: 'ai-plugin.json', desc: 'AI Plugin manifest (ChatGPT/Claude integration ready)' },
                        'mcpJson': { name: 'mcp.json', desc: 'Model Context Protocol (MCP) server available' },
                        'openidConfiguration': { name: 'openid-configuration', desc: 'OpenID Connect authentication configured' },
                        'securityTxt': { name: 'security.txt', desc: 'Security contact information available' },
                        'appleAppSiteAssociation': { name: 'apple-app-site-association', desc: 'Apple Universal Links configured' },
                        'assetlinks': { name: 'assetlinks.json', desc: 'Android App Links configured' }
                    };
                    
                    // Check each .well-known file
                    for (const [fieldName, info] of Object.entries(fileDescriptions)) {
                        const fileStatus = wk[fieldName];
                        if (fileStatus && fileStatus.found && fileStatus.valid !== false) {
                            insights.strengths.push(info.desc);
                        }
                    }
                    
                    // Check for missing important AI readiness files
                    const hasAiPlugin = wk.aiPluginJson?.found && wk.aiPluginJson?.valid !== false;
                    const hasMcpJson = wk.mcpJson?.found && wk.mcpJson?.valid !== false;
                    const hasSecurityTxt = wk.securityTxt?.found && wk.securityTxt?.valid !== false;
                    
                    if (!hasAiPlugin) {
                        insights.recommended.push({
                            title: 'Add AI Plugin Manifest',
                            why: 'An ai-plugin.json file enables ChatGPT and Claude to discover and interact with your API or services. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                            fix: 'Create /.well-known/ai-plugin.json with API description, authentication, and endpoint information.',
                            impact: 'Enables AI assistant integration',
                            reference: 'https://platform.openai.com/docs/plugins/introduction',
                            referenceText: 'OpenAI Plugin Documentation'
                        });
                    }
                    
                    if (!hasMcpJson) {
                        insights.recommended.push({
                            title: 'Add Model Context Protocol Server',
                            why: 'MCP enables AI assistants to access your content and services in a standardized way. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                            fix: 'Create /.well-known/mcp.json defining your MCP server endpoints and capabilities.',
                            impact: 'Enables standardized AI integration',
                            reference: 'https://modelcontextprotocol.io/',
                            referenceText: 'Model Context Protocol Documentation'
                        });
                    }
                    
                    if (!hasSecurityTxt) {
                        insights.recommended.push({
                            title: 'Add Security Contact Information',
                            why: 'security.txt provides a standard way for security researchers to contact you about vulnerabilities. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                            fix: 'Create /.well-known/security.txt with Contact, Expires, and optionally Preferred-Languages fields.',
                            impact: 'Improves security posture and responsible disclosure',
                            reference: 'https://securitytxt.org/',
                            referenceText: 'Security.txt Standard'
                        });
                    }
                }
                
                // Check AI Plugin
                if (ar.aiPlugin && ar.aiPlugin.valid) {
                    insights.strengths.push(`AI Plugin: "${ar.aiPlugin.name}" - ${ar.aiPlugin.description}`);
                }
                
                // Check MCP
                if (ar.mcp && ar.mcp.valid) {
                    const capabilities = [];
                    if (ar.mcp.hasResourcesCapability) capabilities.push('resources');
                    if (ar.mcp.hasToolsCapability) capabilities.push('tools');
                    if (ar.mcp.hasPromptsCapability) capabilities.push('prompts');
                    const capStr = capabilities.length > 0 ? ` (${capabilities.join(', ')})` : '';
                    insights.strengths.push(`MCP Server: "${ar.mcp.name}"${capStr}`);
                }
                
                // Check OpenAPI
                if (ar.openapi && ar.openapi.valid) {
                    insights.strengths.push(`OpenAPI Specification: ${ar.openapi.operationCount} endpoint(s) documented`);
                } else if (!ar.openapi) {
                    insights.recommended.push({
                        title: 'Add OpenAPI Specification',
                        why: 'OpenAPI specs enable automatic API documentation, client generation, and AI integration. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                        fix: 'Create an OpenAPI 3.0+ specification and link it via <link rel="service-desc"> in HTML head or document it in ai-plugin.json.',
                        impact: 'Enables API discovery and integration',
                        reference: 'https://swagger.io/specification/',
                        referenceText: 'OpenAPI Specification'
                    });
                }
                
                // Check robots.txt
                if (ar.robotsTxt && ar.robotsTxt.found) {
                    const sitemapInfo = ar.robotsTxt.sitemapCount > 0 ? ` with ${ar.robotsTxt.sitemapCount} sitemap(s)` : '';
                    insights.strengths.push(`robots.txt: Provides crawling guidance${sitemapInfo}`);
                } else if (!ar.robotsTxt || !ar.robotsTxt.found) {
                    insights.recommended.push({
                        title: 'Add robots.txt File',
                        why: 'robots.txt tells search engines and AI crawlers which parts of your site to access. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                        fix: 'Create /robots.txt with User-agent rules and optionally a Sitemap reference.',
                        impact: 'Controls crawler behavior',
                        reference: 'https://developers.google.com/search/docs/crawling-indexing/robots/intro',
                        referenceText: 'Google Robots.txt Guide'
                    });
                }
                
                // Check sitemap
                if (ar.sitemap && ar.sitemap.found) {
                    const urlInfo = ar.sitemap.urlCount > 0 ? ` (${ar.sitemap.urlCount} URL${ar.sitemap.urlCount !== 1 ? 's' : ''})` : '';
                    insights.strengths.push(`XML Sitemap: Helps search engines discover content${urlInfo}`);
                } else if (!ar.sitemap || !ar.sitemap.found) {
                    insights.recommended.push({
                        title: 'Add XML Sitemap',
                        why: 'XML sitemaps help search engines discover and index all your important pages. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                        fix: 'Generate an XML sitemap and reference it in robots.txt or submit it via Google Search Console.',
                        impact: 'Improves indexing coverage',
                        reference: 'https://developers.google.com/search/docs/crawling-indexing/sitemaps/overview',
                        referenceText: 'Google Sitemap Guide'
                    });
                }
                
                // Check semantic HTML
                if (ar.semanticHtml) {
                    const sh = ar.semanticHtml;
                    const hasLandmarks = sh.landmarks && (sh.landmarks.hasMain || sh.landmarks.hasNavigation || sh.landmarks.hasHeader || sh.landmarks.hasFooter);
                    const hasGoodHeadings = sh.headings && sh.headings.hasSingleH1 && sh.headings.properHierarchy;
                    const hasGoodImages = sh.images && sh.images.totalImages > 0 && sh.images.altPercentage > 80;
                    
                    if (hasLandmarks) {
                        const landmarkDetails = [];
                        if (sh.landmarks.hasMain) landmarkDetails.push('main');
                        if (sh.landmarks.hasNavigation) landmarkDetails.push('nav');
                        if (sh.landmarks.hasHeader) landmarkDetails.push('header');
                        if (sh.landmarks.hasFooter) landmarkDetails.push('footer');
                        if (sh.landmarks.articleCount > 0) landmarkDetails.push(`${sh.landmarks.articleCount} article${sh.landmarks.articleCount !== 1 ? 's' : ''}`);
                        insights.strengths.push(`Semantic HTML: Using ${landmarkDetails.join(', ')} elements`);
                    }
                    
                    if (hasGoodHeadings) {
                        insights.strengths.push('Heading Structure: Single H1 with proper hierarchy');
                    }
                    
                    if (hasGoodImages) {
                        insights.strengths.push(`Image Accessibility: ${sh.images.altPercentage}% have alt text`);
                    }
                    
                    if (!hasLandmarks) {
                        insights.recommended.push({
                            title: 'Use Semantic HTML5 Landmark Elements',
                            why: 'Semantic landmarks help search engines and AI understand your content structure. <a href="#" class="switch-to-ai-tab">See the AI Readiness tab for more details</a>.',
                            fix: 'Replace generic <div> tags with semantic elements like <main>, <nav>, <header>, <footer>, <article>, <section>, <aside>.',
                            impact: 'Improves content understanding and accessibility',
                            reference: 'https://developer.mozilla.org/en-US/docs/Web/HTML/Element',
                            referenceText: 'MDN HTML Elements Reference'
                        });
                    }
                }
            }
            
            // Determine overall status
            if (insights.critical.length > 0) {
                insights.overallStatus = 'status-critical';
                insights.statusText = `Critical (${insights.critical.length} issue${insights.critical.length > 1 ? 's' : ''})`;
            } else if (insights.high.length > 0) {
                insights.overallStatus = 'status-needs-attention';
                insights.statusText = `Needs Attention (${insights.high.length} high priority)`;
            } else if (insights.recommended.length > 0) {
                insights.overallStatus = 'status-good';
                insights.statusText = `Good (${insights.recommended.length} improvement${insights.recommended.length > 1 ? 's' : ''} available)`;
            } else {
                insights.overallStatus = 'status-excellent';
                insights.statusText = 'Excellent ‚úì';
            }
            
            return insights;
        }
        
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('error').style.display = 'block';
        }
        
        function formatMarkdownTables(markdown) {
            let html = '';
            const lines = markdown.split('\n');
            let inTable = false;
            let tableHeaders = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check if this is a table row (starts and ends with |)
                if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
                    const cells = line.split('|').slice(1, -1).map(c => c.trim());
                    
                    // Skip separator rows (| --- | --- |)
                    if (cells.every(c => /^-+$/.test(c))) {
                        continue;
                    }
                    
                    if (!inTable) {
                        // Start new table
                        html += '<table>';
                        tableHeaders = cells;
                        html += '<thead><tr>';
                        cells.forEach(cell => html += `<th>${escapeHtml(cell)}</th>`);
                        html += '</tr></thead><tbody>';
                        inTable = true;
                    } else {
                        // Table row
                        html += '<tr>';
                        cells.forEach(cell => html += `<td>${escapeHtml(cell)}</td>`);
                        html += '</tr>';
                    }
                } else {
                    // Not a table row
                    if (inTable) {
                        html += '</tbody></table>';
                        inTable = false;
                    }
                    
                    // Handle separator lines (‚îÄ‚îÄ‚îÄ‚îÄ)
                    if (line.match(/^‚îÄ+$/)) {
                        html += '<hr>';
                    } else {
                        // Regular text line
                        html += escapeHtml(line) + '\n';
                    }
                }
            }
            
            // Close table if still open
            if (inTable) {
                html += '</tbody></table>';
            }
            
            return html;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function syntaxHighlight(json) {
            if (typeof json !== 'string') {
                json = JSON.stringify(json, null, 2);
            }
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
    </script>
</body>
</html>
